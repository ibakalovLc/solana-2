{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/react/node_modules/@solana/codecs-strings/dist/index.browser.mjs","sources":["file:///Users/ivaylobakalov/web3/solana/voting-dapp/frontend/node_modules/%40solana/react/node_modules/%40solana/codecs-strings/src/assertions.ts","file:///Users/ivaylobakalov/web3/solana/voting-dapp/frontend/node_modules/%40solana/react/node_modules/%40solana/codecs-strings/src/baseX.ts","file:///Users/ivaylobakalov/web3/solana/voting-dapp/frontend/node_modules/%40solana/react/node_modules/%40solana/codecs-strings/src/base10.ts","file:///Users/ivaylobakalov/web3/solana/voting-dapp/frontend/node_modules/%40solana/react/node_modules/%40solana/codecs-strings/src/base16.ts","file:///Users/ivaylobakalov/web3/solana/voting-dapp/frontend/node_modules/%40solana/react/node_modules/%40solana/codecs-strings/src/base58.ts","file:///Users/ivaylobakalov/web3/solana/voting-dapp/frontend/node_modules/%40solana/react/node_modules/%40solana/codecs-strings/src/baseX-reslice.ts","file:///Users/ivaylobakalov/web3/solana/voting-dapp/frontend/node_modules/%40solana/react/node_modules/%40solana/codecs-strings/src/base64.ts","file:///Users/ivaylobakalov/web3/solana/voting-dapp/frontend/node_modules/%40solana/react/node_modules/%40solana/codecs-strings/src/null-characters.ts","file:///Users/ivaylobakalov/web3/solana/voting-dapp/frontend/node_modules/%40solana/react/node_modules/%40solana/text-encoding-impl/src/index.browser.ts","file:///Users/ivaylobakalov/web3/solana/voting-dapp/frontend/node_modules/%40solana/react/node_modules/%40solana/codecs-strings/src/utf8.ts"],"sourcesContent":["import { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\n/**\n * Asserts that a given string contains only characters from the specified alphabet.\n *\n * This function validates whether a string consists exclusively of characters\n * from the provided `alphabet`. If the validation fails, it throws an error\n * indicating the invalid base string.\n *\n * @param alphabet - The allowed set of characters for the base encoding.\n * @param testValue - The string to validate against the given alphabet.\n * @param givenValue - The original string provided by the user (defaults to `testValue`).\n *\n * @throws {SolanaError} If `testValue` contains characters not present in `alphabet`.\n *\n * @example\n * Validating a base-8 encoded string.\n * ```ts\n * assertValidBaseString('01234567', '123047'); // Passes\n * assertValidBaseString('01234567', '128');    // Throws error\n * ```\n */\nexport function assertValidBaseString(alphabet: string, testValue: string, givenValue = testValue) {\n    if (!testValue.match(new RegExp(`^[${alphabet}]*$`))) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n            alphabet,\n            base: alphabet.length,\n            value: givenValue,\n        });\n    }\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertValidBaseString } from './assertions';\n\n/**\n * Returns an encoder for base-X encoded strings.\n *\n * This encoder serializes strings using a custom alphabet, treating the length of the alphabet as the base.\n * The encoding process involves converting the input string to a numeric value in base-X, then\n * encoding that value into bytes while preserving leading zeroes.\n *\n * For more details, see {@link getBaseXCodec}.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @returns A `VariableSizeEncoder<string>` for encoding base-X strings.\n *\n * @example\n * Encoding a base-X string using a custom alphabet.\n * ```ts\n * const encoder = getBaseXEncoder('0123456789abcdef');\n * const bytes = encoder.encode('deadface'); // 0xdeadface\n * ```\n *\n * @see {@link getBaseXCodec}\n */\nexport const getBaseXEncoder = (alphabet: string): VariableSizeEncoder<string> => {\n    return createEncoder({\n        getSizeFromValue: (value: string): number => {\n            const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet[0]);\n            if (!tailChars) return value.length;\n\n            const base10Number = getBigIntFromBaseX(tailChars, alphabet);\n            return leadingZeroes.length + Math.ceil(base10Number.toString(16).length / 2);\n        },\n        write(value: string, bytes, offset) {\n            // Check if the value is valid.\n            assertValidBaseString(alphabet, value);\n            if (value === '') return offset;\n\n            // Handle leading zeroes.\n            const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet[0]);\n            if (!tailChars) {\n                bytes.set(new Uint8Array(leadingZeroes.length).fill(0), offset);\n                return offset + leadingZeroes.length;\n            }\n\n            // From baseX to base10.\n            let base10Number = getBigIntFromBaseX(tailChars, alphabet);\n\n            // From base10 to bytes.\n            const tailBytes: number[] = [];\n            while (base10Number > 0n) {\n                tailBytes.unshift(Number(base10Number % 256n));\n                base10Number /= 256n;\n            }\n\n            const bytesToAdd = [...Array(leadingZeroes.length).fill(0), ...tailBytes];\n            bytes.set(bytesToAdd, offset);\n            return offset + bytesToAdd.length;\n        },\n    });\n};\n\n/**\n * Returns a decoder for base-X encoded strings.\n *\n * This decoder deserializes base-X encoded strings from a byte array using a custom alphabet.\n * The decoding process converts the byte array into a numeric value in base-10, then\n * maps that value back to characters in the specified base-X alphabet.\n *\n * For more details, see {@link getBaseXCodec}.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @returns A `VariableSizeDecoder<string>` for decoding base-X strings.\n *\n * @example\n * Decoding a base-X string using a custom alphabet.\n * ```ts\n * const decoder = getBaseXDecoder('0123456789abcdef');\n * const value = decoder.decode(new Uint8Array([0xde, 0xad, 0xfa, 0xce])); // \"deadface\"\n * ```\n *\n * @see {@link getBaseXCodec}\n */\nexport const getBaseXDecoder = (alphabet: string): VariableSizeDecoder<string> => {\n    return createDecoder({\n        read(rawBytes, offset): [string, number] {\n            const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);\n            if (bytes.length === 0) return ['', 0];\n\n            // Handle leading zeroes.\n            let trailIndex = bytes.findIndex(n => n !== 0);\n            trailIndex = trailIndex === -1 ? bytes.length : trailIndex;\n            const leadingZeroes = alphabet[0].repeat(trailIndex);\n            if (trailIndex === bytes.length) return [leadingZeroes, rawBytes.length];\n\n            // From bytes to base10.\n            const base10Number = bytes.slice(trailIndex).reduce((sum, byte) => sum * 256n + BigInt(byte), 0n);\n\n            // From base10 to baseX.\n            const tailChars = getBaseXFromBigInt(base10Number, alphabet);\n\n            return [leadingZeroes + tailChars, rawBytes.length];\n        },\n    });\n};\n\n/**\n * Returns a codec for encoding and decoding base-X strings.\n *\n * This codec serializes strings using a custom alphabet, treating the length of the alphabet as the base.\n * The encoding process converts the input string into a numeric value in base-X, which is then encoded as bytes.\n * The decoding process reverses this transformation to reconstruct the original string.\n *\n * This codec supports leading zeroes by treating the first character of the alphabet as the zero character.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-X strings.\n *\n * @example\n * Encoding and decoding a base-X string using a custom alphabet.\n * ```ts\n * const codec = getBaseXCodec('0123456789abcdef');\n * const bytes = codec.encode('deadface'); // 0xdeadface\n * const value = codec.decode(bytes);      // \"deadface\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-X codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBaseXCodec('0123456789abcdef'), 8);\n * ```\n *\n * If you need a size-prefixed base-X codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBaseXCodec('0123456789abcdef'), getU32Codec());\n * ```\n *\n * Separate {@link getBaseXEncoder} and {@link getBaseXDecoder} functions are available.\n *\n * ```ts\n * const bytes = getBaseXEncoder('0123456789abcdef').encode('deadface');\n * const value = getBaseXDecoder('0123456789abcdef').decode(bytes);\n * ```\n *\n * @see {@link getBaseXEncoder}\n * @see {@link getBaseXDecoder}\n */\nexport const getBaseXCodec = (alphabet: string): VariableSizeCodec<string> =>\n    combineCodec(getBaseXEncoder(alphabet), getBaseXDecoder(alphabet));\n\nfunction partitionLeadingZeroes(\n    value: string,\n    zeroCharacter: string,\n): [leadingZeros: string, tailChars: string | undefined] {\n    const [leadingZeros, tailChars] = value.split(new RegExp(`((?!${zeroCharacter}).*)`));\n    return [leadingZeros, tailChars];\n}\n\nfunction getBigIntFromBaseX(value: string, alphabet: string): bigint {\n    const base = BigInt(alphabet.length);\n    let sum = 0n;\n    for (const char of value) {\n        sum *= base;\n        sum += BigInt(alphabet.indexOf(char));\n    }\n    return sum;\n}\n\nfunction getBaseXFromBigInt(value: bigint, alphabet: string): string {\n    const base = BigInt(alphabet.length);\n    const tailChars = [];\n    while (value > 0n) {\n        tailChars.unshift(alphabet[Number(value % base)]);\n        value /= base;\n    }\n    return tailChars.join('');\n}\n","import { getBaseXCodec, getBaseXDecoder, getBaseXEncoder } from './baseX';\n\nconst alphabet = '0123456789';\n\n/**\n * Returns an encoder for base-10 strings.\n *\n * This encoder serializes strings using a base-10 encoding scheme.\n * The output consists of bytes representing the numerical values of the input string.\n *\n * For more details, see {@link getBase10Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding base-10 strings.\n *\n * @example\n * Encoding a base-10 string.\n * ```ts\n * const encoder = getBase10Encoder();\n * const bytes = encoder.encode('1024'); // 0x0400\n * ```\n *\n * @see {@link getBase10Codec}\n */\nexport const getBase10Encoder = () => getBaseXEncoder(alphabet);\n\n/**\n * Returns a decoder for base-10 strings.\n *\n * This decoder deserializes base-10 encoded strings from a byte array.\n *\n * For more details, see {@link getBase10Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding base-10 strings.\n *\n * @example\n * Decoding a base-10 string.\n * ```ts\n * const decoder = getBase10Decoder();\n * const value = decoder.decode(new Uint8Array([0x04, 0x00])); // \"1024\"\n * ```\n *\n * @see {@link getBase10Codec}\n */\nexport const getBase10Decoder = () => getBaseXDecoder(alphabet);\n\n/**\n * Returns a codec for encoding and decoding base-10 strings.\n *\n * This codec serializes strings using a base-10 encoding scheme.\n * The output consists of bytes representing the numerical values of the input string.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-10 strings.\n *\n * @example\n * Encoding and decoding a base-10 string.\n * ```ts\n * const codec = getBase10Codec();\n * const bytes = codec.encode('1024'); // 0x0400\n * const value = codec.decode(bytes);  // \"1024\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-10 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBase10Codec(), 5);\n * ```\n *\n * If you need a size-prefixed base-10 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBase10Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getBase10Encoder} and {@link getBase10Decoder} functions are available.\n *\n * ```ts\n * const bytes = getBase10Encoder().encode('1024');\n * const value = getBase10Decoder().decode(bytes);\n * ```\n *\n * @see {@link getBase10Encoder}\n * @see {@link getBase10Decoder}\n */\nexport const getBase10Codec = () => getBaseXCodec(alphabet);\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\nconst enum HexC {\n    ZERO = 48, // 0\n    NINE = 57, // 9\n    A_UP = 65, // A\n    F_UP = 70, // F\n    A_LO = 97, // a\n    F_LO = 102, // f\n}\n\nconst INVALID_STRING_ERROR_BASE_CONFIG = {\n    alphabet: '0123456789abcdef',\n    base: 16,\n} as const;\n\nfunction charCodeToBase16(char: number) {\n    if (char >= HexC.ZERO && char <= HexC.NINE) return char - HexC.ZERO;\n    if (char >= HexC.A_UP && char <= HexC.F_UP) return char - (HexC.A_UP - 10);\n    if (char >= HexC.A_LO && char <= HexC.F_LO) return char - (HexC.A_LO - 10);\n}\n\n/**\n * Returns an encoder for base-16 (hexadecimal) strings.\n *\n * This encoder serializes strings using a base-16 encoding scheme.\n * The output consists of bytes representing the hexadecimal values of the input string.\n *\n * For more details, see {@link getBase16Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding base-16 strings.\n *\n * @example\n * Encoding a base-16 string.\n * ```ts\n * const encoder = getBase16Encoder();\n * const bytes = encoder.encode('deadface'); // 0xdeadface\n * ```\n *\n * @see {@link getBase16Codec}\n */\nexport const getBase16Encoder = (): VariableSizeEncoder<string> =>\n    createEncoder({\n        getSizeFromValue: (value: string) => Math.ceil(value.length / 2),\n        write(value: string, bytes, offset) {\n            const len = value.length;\n            const al = len / 2;\n            if (len === 1) {\n                const c = value.charCodeAt(0);\n                const n = charCodeToBase16(c);\n                if (n === undefined) {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        ...INVALID_STRING_ERROR_BASE_CONFIG,\n                        value,\n                    });\n                }\n                bytes.set([n], offset);\n                return 1 + offset;\n            }\n            const hexBytes = new Uint8Array(al);\n            for (let i = 0, j = 0; i < al; i++) {\n                const c1 = value.charCodeAt(j++);\n                const c2 = value.charCodeAt(j++);\n\n                const n1 = charCodeToBase16(c1);\n                const n2 = charCodeToBase16(c2);\n                if (n1 === undefined || (n2 === undefined && !Number.isNaN(c2))) {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        ...INVALID_STRING_ERROR_BASE_CONFIG,\n                        value,\n                    });\n                }\n                hexBytes[i] = !Number.isNaN(c2) ? (n1 << 4) | (n2 ?? 0) : n1;\n            }\n\n            bytes.set(hexBytes, offset);\n            return hexBytes.length + offset;\n        },\n    });\n\n/**\n * Returns a decoder for base-16 (hexadecimal) strings.\n *\n * This decoder deserializes base-16 encoded strings from a byte array.\n *\n * For more details, see {@link getBase16Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding base-16 strings.\n *\n * @example\n * Decoding a base-16 string.\n * ```ts\n * const decoder = getBase16Decoder();\n * const value = decoder.decode(new Uint8Array([0xde, 0xad, 0xfa, 0xce])); // \"deadface\"\n * ```\n *\n * @see {@link getBase16Codec}\n */\nexport const getBase16Decoder = (): VariableSizeDecoder<string> =>\n    createDecoder({\n        read(bytes, offset) {\n            const value = bytes.slice(offset).reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n            return [value, bytes.length];\n        },\n    });\n\n/**\n * Returns a codec for encoding and decoding base-16 (hexadecimal) strings.\n *\n * This codec serializes strings using a base-16 encoding scheme.\n * The output consists of bytes representing the hexadecimal values of the input string.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-16 strings.\n *\n * @example\n * Encoding and decoding a base-16 string.\n * ```ts\n * const codec = getBase16Codec();\n * const bytes = codec.encode('deadface'); // 0xdeadface\n * const value = codec.decode(bytes);      // \"deadface\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-16 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBase16Codec(), 8);\n * ```\n *\n * If you need a size-prefixed base-16 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBase16Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getBase16Encoder} and {@link getBase16Decoder} functions are available.\n *\n * ```ts\n * const bytes = getBase16Encoder().encode('deadface');\n * const value = getBase16Decoder().decode(bytes);\n * ```\n *\n * @see {@link getBase16Encoder}\n * @see {@link getBase16Decoder}\n */\nexport const getBase16Codec = (): VariableSizeCodec<string> => combineCodec(getBase16Encoder(), getBase16Decoder());\n","import { getBaseXCodec, getBaseXDecoder, getBaseXEncoder } from './baseX';\n\nconst alphabet = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\n\n/**\n * Returns an encoder for base-58 strings.\n *\n * This encoder serializes strings using a base-58 encoding scheme,\n * commonly used in cryptocurrency addresses and other compact representations.\n *\n * For more details, see {@link getBase58Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding base-58 strings.\n *\n * @example\n * Encoding a base-58 string.\n * ```ts\n * const encoder = getBase58Encoder();\n * const bytes = encoder.encode('heLLo'); // 0x1b6a3070\n * ```\n *\n * @see {@link getBase58Codec}\n */\nexport const getBase58Encoder = () => getBaseXEncoder(alphabet);\n\n/**\n * Returns a decoder for base-58 strings.\n *\n * This decoder deserializes base-58 encoded strings from a byte array.\n *\n * For more details, see {@link getBase58Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding base-58 strings.\n *\n * @example\n * Decoding a base-58 string.\n * ```ts\n * const decoder = getBase58Decoder();\n * const value = decoder.decode(new Uint8Array([0x1b, 0x6a, 0x30, 0x70])); // \"heLLo\"\n * ```\n *\n * @see {@link getBase58Codec}\n */\nexport const getBase58Decoder = () => getBaseXDecoder(alphabet);\n\n/**\n * Returns a codec for encoding and decoding base-58 strings.\n *\n * This codec serializes strings using a base-58 encoding scheme,\n * commonly used in cryptocurrency addresses and other compact representations.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-58 strings.\n *\n * @example\n * Encoding and decoding a base-58 string.\n * ```ts\n * const codec = getBase58Codec();\n * const bytes = codec.encode('heLLo'); // 0x1b6a3070\n * const value = codec.decode(bytes);   // \"heLLo\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-58 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBase58Codec(), 8);\n * ```\n *\n * If you need a size-prefixed base-58 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBase58Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getBase58Encoder} and {@link getBase58Decoder} functions are available.\n *\n * ```ts\n * const bytes = getBase58Encoder().encode('heLLo');\n * const value = getBase58Decoder().decode(bytes);\n * ```\n *\n * @see {@link getBase58Encoder}\n * @see {@link getBase58Decoder}\n */\nexport const getBase58Codec = () => getBaseXCodec(alphabet);\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertValidBaseString } from './assertions';\n\n/**\n * Returns an encoder for base-X encoded strings using bit re-slicing.\n *\n * This encoder serializes strings by dividing the input into custom-sized bit chunks,\n * mapping them to an alphabet, and encoding the result into a byte array.\n * This approach is commonly used for encoding schemes where the alphabet's length is a power of 2,\n * such as base-16 or base-64.\n *\n * For more details, see {@link getBaseXResliceCodec}.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @param bits - The number of bits per encoded chunk, typically `log2(alphabet.length)`.\n * @returns A `VariableSizeEncoder<string>` for encoding base-X strings using bit re-slicing.\n *\n * @example\n * Encoding a base-X string using bit re-slicing.\n * ```ts\n * const encoder = getBaseXResliceEncoder('elho', 2);\n * const bytes = encoder.encode('hellolol'); // 0x4aee\n * ```\n *\n * @see {@link getBaseXResliceCodec}\n */\nexport const getBaseXResliceEncoder = (alphabet: string, bits: number): VariableSizeEncoder<string> =>\n    createEncoder({\n        getSizeFromValue: (value: string) => Math.floor((value.length * bits) / 8),\n        write(value: string, bytes, offset) {\n            assertValidBaseString(alphabet, value);\n            if (value === '') return offset;\n            const charIndices = [...value].map(c => alphabet.indexOf(c));\n            const reslicedBytes = reslice(charIndices, bits, 8, false);\n            bytes.set(reslicedBytes, offset);\n            return reslicedBytes.length + offset;\n        },\n    });\n\n/**\n * Returns a decoder for base-X encoded strings using bit re-slicing.\n *\n * This decoder deserializes base-X encoded strings by re-slicing the bits of a byte array into\n * custom-sized chunks and mapping them to a specified alphabet.\n * This is typically used for encoding schemes where the alphabet's length is a power of 2,\n * such as base-16 or base-64.\n *\n * For more details, see {@link getBaseXResliceCodec}.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @param bits - The number of bits per encoded chunk, typically `log2(alphabet.length)`.\n * @returns A `VariableSizeDecoder<string>` for decoding base-X strings using bit re-slicing.\n *\n * @example\n * Decoding a base-X string using bit re-slicing.\n * ```ts\n * const decoder = getBaseXResliceDecoder('elho', 2);\n * const value = decoder.decode(new Uint8Array([0x4a, 0xee])); // \"hellolol\"\n * ```\n *\n * @see {@link getBaseXResliceCodec}\n */\nexport const getBaseXResliceDecoder = (alphabet: string, bits: number): VariableSizeDecoder<string> =>\n    createDecoder({\n        read(rawBytes, offset = 0): [string, number] {\n            const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);\n            if (bytes.length === 0) return ['', rawBytes.length];\n            const charIndices = reslice([...bytes], 8, bits, true);\n            return [charIndices.map(i => alphabet[i]).join(''), rawBytes.length];\n        },\n    });\n\n/**\n * Returns a codec for encoding and decoding base-X strings using bit re-slicing.\n *\n * This codec serializes strings by dividing the input into custom-sized bit chunks,\n * mapping them to a given alphabet, and encoding the result into bytes.\n * It is particularly suited for encoding schemes where the alphabet's length is a power of 2,\n * such as base-16 or base-64.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @param bits - The number of bits per encoded chunk, typically `log2(alphabet.length)`.\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-X strings using bit re-slicing.\n *\n * @example\n * Encoding and decoding a base-X string using bit re-slicing.\n * ```ts\n * const codec = getBaseXResliceCodec('elho', 2);\n * const bytes = codec.encode('hellolol'); // 0x4aee\n * const value = codec.decode(bytes);      // \"hellolol\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-X codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBaseXResliceCodec('elho', 2), 8);\n * ```\n *\n * If you need a size-prefixed base-X codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBaseXResliceCodec('elho', 2), getU32Codec());\n * ```\n *\n * Separate {@link getBaseXResliceEncoder} and {@link getBaseXResliceDecoder} functions are available.\n *\n * ```ts\n * const bytes = getBaseXResliceEncoder('elho', 2).encode('hellolol');\n * const value = getBaseXResliceDecoder('elho', 2).decode(bytes);\n * ```\n *\n * @see {@link getBaseXResliceEncoder}\n * @see {@link getBaseXResliceDecoder}\n */\nexport const getBaseXResliceCodec = (alphabet: string, bits: number): VariableSizeCodec<string> =>\n    combineCodec(getBaseXResliceEncoder(alphabet, bits), getBaseXResliceDecoder(alphabet, bits));\n\n/** Helper function to reslice the bits inside bytes. */\nfunction reslice(input: number[], inputBits: number, outputBits: number, useRemainder: boolean): number[] {\n    const output = [];\n    let accumulator = 0;\n    let bitsInAccumulator = 0;\n    const mask = (1 << outputBits) - 1;\n    for (const value of input) {\n        accumulator = (accumulator << inputBits) | value;\n        bitsInAccumulator += inputBits;\n        while (bitsInAccumulator >= outputBits) {\n            bitsInAccumulator -= outputBits;\n            output.push((accumulator >> bitsInAccumulator) & mask);\n        }\n    }\n    if (useRemainder && bitsInAccumulator > 0) {\n        output.push((accumulator << (outputBits - bitsInAccumulator)) & mask);\n    }\n    return output;\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\nimport { assertValidBaseString } from './assertions';\nimport { getBaseXResliceDecoder, getBaseXResliceEncoder } from './baseX-reslice';\n\nconst alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n/**\n * Returns an encoder for base-64 strings.\n *\n * This encoder serializes strings using a base-64 encoding scheme,\n * commonly used for data encoding in URLs, cryptographic keys, and binary-to-text encoding.\n *\n * For more details, see {@link getBase64Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding base-64 strings.\n *\n * @example\n * Encoding a base-64 string.\n * ```ts\n * const encoder = getBase64Encoder();\n * const bytes = encoder.encode('hello+world'); // 0x85e965a3ec28ae57\n * ```\n *\n * @see {@link getBase64Codec}\n */\nexport const getBase64Encoder = (): VariableSizeEncoder<string> => {\n    if (__BROWSER__) {\n        return createEncoder({\n            getSizeFromValue: (value: string) => {\n                try {\n                    return (atob as Window['atob'])(value).length;\n                } catch {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        alphabet,\n                        base: 64,\n                        value,\n                    });\n                }\n            },\n            write(value: string, bytes, offset) {\n                try {\n                    const bytesToAdd = (atob as Window['atob'])(value)\n                        .split('')\n                        .map(c => c.charCodeAt(0));\n                    bytes.set(bytesToAdd, offset);\n                    return bytesToAdd.length + offset;\n                } catch {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        alphabet,\n                        base: 64,\n                        value,\n                    });\n                }\n            },\n        });\n    }\n\n    if (__NODEJS__) {\n        return createEncoder({\n            getSizeFromValue: (value: string) => Buffer.from(value, 'base64').length,\n            write(value: string, bytes, offset) {\n                assertValidBaseString(alphabet, value.replace(/=/g, ''));\n                const buffer = Buffer.from(value, 'base64');\n                bytes.set(buffer, offset);\n                return buffer.length + offset;\n            },\n        });\n    }\n\n    return transformEncoder(getBaseXResliceEncoder(alphabet, 6), (value: string): string => value.replace(/=/g, ''));\n};\n\n/**\n * Returns a decoder for base-64 strings.\n *\n * This decoder deserializes base-64 encoded strings from a byte array.\n *\n * For more details, see {@link getBase64Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding base-64 strings.\n *\n * @example\n * Decoding a base-64 string.\n * ```ts\n * const decoder = getBase64Decoder();\n * const value = decoder.decode(new Uint8Array([0x85, 0xe9, 0x65, 0xa3, 0xec, 0x28, 0xae, 0x57])); // \"hello+world\"\n * ```\n *\n * @see {@link getBase64Codec}\n */\nexport const getBase64Decoder = (): VariableSizeDecoder<string> => {\n    if (__BROWSER__) {\n        return createDecoder({\n            read(bytes, offset = 0) {\n                const slice = bytes.slice(offset);\n                const value = (btoa as Window['btoa'])(String.fromCharCode(...slice));\n                return [value, bytes.length];\n            },\n        });\n    }\n\n    if (__NODEJS__) {\n        return createDecoder({\n            read: (bytes, offset = 0) => [Buffer.from(bytes, offset).toString('base64'), bytes.length],\n        });\n    }\n\n    return transformDecoder(getBaseXResliceDecoder(alphabet, 6), (value: string): string =>\n        value.padEnd(Math.ceil(value.length / 4) * 4, '='),\n    );\n};\n\n/**\n * Returns a codec for encoding and decoding base-64 strings.\n *\n * This codec serializes strings using a base-64 encoding scheme,\n * commonly used for data encoding in URLs, cryptographic keys, and binary-to-text encoding.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-64 strings.\n *\n * @example\n * Encoding and decoding a base-64 string.\n * ```ts\n * const codec = getBase64Codec();\n * const bytes = codec.encode('hello+world'); // 0x85e965a3ec28ae57\n * const value = codec.decode(bytes);         // \"hello+world\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-64 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBase64Codec(), 8);\n * ```\n *\n * If you need a size-prefixed base-64 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBase64Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getBase64Encoder} and {@link getBase64Decoder} functions are available.\n *\n * ```ts\n * const bytes = getBase64Encoder().encode('hello+world');\n * const value = getBase64Decoder().decode(bytes);\n * ```\n *\n * @see {@link getBase64Encoder}\n * @see {@link getBase64Decoder}\n */\nexport const getBase64Codec = (): VariableSizeCodec<string> => combineCodec(getBase64Encoder(), getBase64Decoder());\n","/**\n * Removes all null characters (`\\u0000`) from a string.\n *\n * This function cleans a string by stripping out any null characters,\n * which are often used as padding in fixed-size string encodings.\n *\n * @param value - The string to process.\n * @returns The input string with all null characters removed.\n *\n * @example\n * Removing null characters from a string.\n * ```ts\n * removeNullCharacters('hello\\u0000\\u0000'); // \"hello\"\n * ```\n */\nexport const removeNullCharacters = (value: string) =>\n    // eslint-disable-next-line no-control-regex\n    value.replace(/\\u0000/g, '');\n\n/**\n * Pads a string with null characters (`\\u0000`) at the end to reach a fixed length.\n *\n * If the input string is shorter than the specified length, it is padded with null characters\n * until it reaches the desired size. If it is already long enough, it remains unchanged.\n *\n * @param value - The string to pad.\n * @param chars - The total length of the resulting string, including padding.\n * @returns The input string padded with null characters up to the specified length.\n *\n * @example\n * Padding a string with null characters.\n * ```ts\n * padNullCharacters('hello', 8); // \"hello\\u0000\\u0000\\u0000\"\n * ```\n */\nexport const padNullCharacters = (value: string, chars: number) => value.padEnd(chars, '\\u0000');\n","export const TextDecoder = globalThis.TextDecoder;\nexport const TextEncoder = globalThis.TextEncoder;\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { TextDecoder, TextEncoder } from '@solana/text-encoding-impl';\n\nimport { removeNullCharacters } from './null-characters';\n\n/**\n * Returns an encoder for UTF-8 strings.\n *\n * This encoder serializes strings using UTF-8 encoding.\n * The encoded output contains as many bytes as needed to represent the string.\n *\n * For more details, see {@link getUtf8Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding UTF-8 strings.\n *\n * @example\n * Encoding a UTF-8 string.\n * ```ts\n * const encoder = getUtf8Encoder();\n * const bytes = encoder.encode('hello'); // 0x68656c6c6f\n * ```\n *\n * @see {@link getUtf8Codec}\n */\nexport const getUtf8Encoder = (): VariableSizeEncoder<string> => {\n    let textEncoder: TextEncoder;\n    return createEncoder({\n        getSizeFromValue: value => (textEncoder ||= new TextEncoder()).encode(value).length,\n        write: (value: string, bytes, offset) => {\n            const bytesToAdd = (textEncoder ||= new TextEncoder()).encode(value);\n            bytes.set(bytesToAdd, offset);\n            return offset + bytesToAdd.length;\n        },\n    });\n};\n\n/**\n * Returns a decoder for UTF-8 strings.\n *\n * This decoder deserializes UTF-8 encoded strings from a byte array.\n * It reads all available bytes starting from the given offset.\n *\n * For more details, see {@link getUtf8Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding UTF-8 strings.\n *\n * @example\n * Decoding a UTF-8 string.\n * ```ts\n * const decoder = getUtf8Decoder();\n * const value = decoder.decode(new Uint8Array([0x68, 0x65, 0x6c, 0x6c, 0x6f])); // \"hello\"\n * ```\n *\n * @see {@link getUtf8Codec}\n */\nexport const getUtf8Decoder = (): VariableSizeDecoder<string> => {\n    let textDecoder: TextDecoder;\n    return createDecoder({\n        read(bytes, offset) {\n            const value = (textDecoder ||= new TextDecoder()).decode(bytes.slice(offset));\n            return [removeNullCharacters(value), bytes.length];\n        },\n    });\n};\n\n/**\n * Returns a codec for encoding and decoding UTF-8 strings.\n *\n * This codec serializes strings using UTF-8 encoding.\n * The encoded output contains as many bytes as needed to represent the string.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding UTF-8 strings.\n *\n * @example\n * Encoding and decoding a UTF-8 string.\n * ```ts\n * const codec = getUtf8Codec();\n * const bytes = codec.encode('hello'); // 0x68656c6c6f\n * const value = codec.decode(bytes);   // \"hello\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size UTF-8 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getUtf8Codec(), 5);\n * ```\n *\n * If you need a size-prefixed UTF-8 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getUtf8Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getUtf8Encoder} and {@link getUtf8Decoder} functions are available.\n *\n * ```ts\n * const bytes = getUtf8Encoder().encode('hello');\n * const value = getUtf8Decoder().decode(bytes);\n * ```\n *\n * @see {@link getUtf8Encoder}\n * @see {@link getUtf8Decoder}\n */\nexport const getUtf8Codec = (): VariableSizeCodec<string> => combineCodec(getUtf8Encoder(), getUtf8Decoder());\n"],"names":["alphabet","createEncoder","SolanaError","SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE","createDecoder","combineCodec","TextDecoder","TextEncoder"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsBO,SAAS,qBAAsBA,CAAAA,SAAAA,EAAkB,SAAmB;qBAAA,UAAA,uDAAa,SAAW,EAAA;IAC3F,IAAA,CAAC,UAAU,KAAM,CAAA,IAAI,OAAO,AAAKA,EAAAA,UAAAA,SAAQ,EAAK,GAAA,CAAA,CAAC,CAAG,IAAA;QAC5C,MAAA,IAAI,sNAAA,CAAY,wPAA+C,EAAA;YACjE,QAAAA,EAAAA,SAAAA;YACA,MAAMA,SAAS,CAAA,MAAA;YACf,KAAO,EAAA;QAAA,CACV,CAAA;IAAA;AAET;ACEa,IAAA,eAAA,GAAkB,CAACA,SAAkD,KAAA;IAC9E,WAAO,gOAAc,EAAA;QACjB,gBAAA,EAAkB,CAAC,KAA0B,KAAA;YACnC,MAAA,CAAC,eAAe,SAAS,CAAA,GAAI,uBAAuB,KAAOA,EAAAA,SAAAA,CAAS,CAAC,CAAC,CAAA;YACxE,IAAA,CAAC,SAAW,EAAA,OAAO,KAAM,CAAA,MAAA;YAEvB,MAAA,YAAA,GAAe,kBAAmB,CAAA,SAAA,EAAWA,SAAQ,CAAA;YACpD,OAAA,aAAA,CAAc,MAAA,GAAS,IAAK,CAAA,IAAA,CAAK,aAAa,QAAS,CAAA,EAAE,CAAE,CAAA,MAAA,GAAS,CAAC,CAAA;QAAA,CAChF;QACA,KAAA,EAAM,KAAe,EAAA,KAAA,EAAO,MAAQ,EAAA;YAEhC,qBAAA,CAAsBA,WAAU,KAAK,CAAA;YACjC,IAAA,KAAA,KAAU,IAAW,OAAA,MAAA;YAGnB,MAAA,CAAC,eAAe,SAAS,CAAA,GAAI,uBAAuB,KAAOA,EAAAA,SAAAA,CAAS,CAAC,CAAC,CAAA;YAC5E,IAAI,CAAC,SAAW,EAAA;gBACN,KAAA,CAAA,GAAA,CAAI,IAAI,UAAW,CAAA,aAAA,CAAc,MAAM,CAAE,CAAA,IAAA,CAAK,CAAC,CAAA,EAAG,MAAM,CAAA;gBAC9D,OAAO,SAAS,aAAc,CAAA,MAAA;YAAA;YAI9B,IAAA,YAAA,GAAe,kBAAmB,CAAA,SAAA,EAAWA,SAAQ,CAAA;YAGzD,MAAM,YAAsB,EAAC;YAC7B,MAAO,eAAe,EAAI,CAAA;gBACtB,SAAA,CAAU,OAAQ,CAAA,MAAA,CAAO,YAAe,GAAA,IAAI,CAAC,CAAA;gBAC7B,YAAA,IAAA,IAAA;YAAA;YAGd,MAAA,UAAA,GAAa,CAAC;mBAAG,KAAM,CAAA,aAAA,CAAc,MAAM,CAAA,CAAE,IAAK,CAAA,CAAC,CAAG,EAAA;mBAAG,SAAS;aAAA;YAClE,KAAA,CAAA,GAAA,CAAI,YAAY,MAAM,CAAA;YAC5B,OAAO,SAAS,UAAW,CAAA,MAAA;QAAA;IAC/B,CACH,CAAA;AACL;AAuBa,IAAA,eAAA,GAAkB,CAACA,SAAkD,KAAA;IAC9E,WAAO,gOAAc,EAAA;QACjB,IAAA,EAAK,QAAA,EAAU,MAA0B,EAAA;YACrC,MAAM,QAAQ,MAAW,KAAA,CAAA,GAAI,QAAW,GAAA,QAAA,CAAS,KAAA,CAAM,MAAM,CAAA;YAC7D,IAAI,MAAM,MAAW,KAAA,CAAA,EAAU,OAAA;gBAAC;gBAAI,CAAC;aAAA;YAGrC,IAAI,UAAa,GAAA,KAAA,CAAM,SAAU,CAAA,CAAA,CAAA,GAAK,MAAM,CAAC,CAAA;YAChC,UAAA,GAAA,UAAA,KAAe,CAAA,CAAK,GAAA,KAAA,CAAM,MAAS,GAAA,UAAA;YAChD,MAAM,aAAgBA,GAAAA,SAAAA,CAAS,CAAC,CAAA,CAAE,MAAA,CAAO,UAAU,CAAA;YACnD,IAAI,eAAe,KAAM,CAAA,MAAA,EAAA,OAAe;gBAAC,aAAA;gBAAe,SAAS,MAAM;aAAA;YAGvE,MAAM,YAAe,GAAA,KAAA,CAAM,KAAM,CAAA,UAAU,EAAE,MAAO,CAAA,CAAC,GAAK,EAAA,IAAA,GAAS,GAAM,GAAA,IAAA,GAAO,MAAO,CAAA,IAAI,GAAG,EAAE,CAAA;YAG1F,MAAA,SAAA,GAAY,kBAAmB,CAAA,YAAA,EAAcA,SAAQ,CAAA;YAE3D,OAAO;gBAAC,aAAA,GAAgB,SAAW;gBAAA,QAAA,CAAS,MAAM;aAAA;QAAA;IACtD,CACH,CAAA;AACL;AA+Ca,IAAA,aAAA,GAAgB,CAACA,SAC1B,GAAA,mOAAA,EAAa,gBAAgBA,SAAQ,CAAA,EAAG,eAAgBA,CAAAA,SAAQ,CAAC;AAErE,SAAS,sBAAA,CACL,KAAA,EACA,aACqD,EAAA;IAC/C,MAAA,CAAC,YAAc,EAAA,SAAS,CAAI,GAAA,KAAA,CAAM,KAAM,CAAA,IAAI,MAAO,CAAA,IAAA,UAAO,aAAa,EAAA,IAAA,CAAM,CAAC,CAAA;IAC7E,OAAA;QAAC;QAAc,SAAS;KAAA;AACnC;AAEA,SAAS,kBAAA,CAAmB,KAAA,EAAeA,SAA0B,EAAA;IAC3D,MAAA,IAAA,GAAO,MAAOA,CAAAA,SAAAA,CAAS,MAAM,CAAA;IACnC,IAAI,GAAM,GAAA,EAAA;IACV,KAAA,MAAW,QAAQ,KAAO,CAAA;QACf,GAAA,IAAA,IAAA;QACP,GAAA,IAAO,MAAOA,CAAAA,SAAAA,CAAS,OAAQ,CAAA,IAAI,CAAC,CAAA;IAAA;IAEjC,OAAA,GAAA;AACX;AAEA,SAAS,kBAAA,CAAmB,KAAA,EAAeA,SAA0B,EAAA;IAC3D,MAAA,IAAA,GAAO,MAAOA,CAAAA,SAAAA,CAAS,MAAM,CAAA;IACnC,MAAM,YAAY,EAAC;IACnB,MAAO,QAAQ,EAAI,CAAA;QACf,SAAA,CAAU,OAAA,CAAQA,SAAS,CAAA,MAAA,CAAO,KAAQ,GAAA,IAAI,CAAC,CAAC,CAAA;QACvC,KAAA,IAAA,IAAA;IAAA;IAEN,OAAA,SAAA,CAAU,IAAA,CAAK,EAAE,CAAA;AAC5B;;AC1LA,IAAM,QAAW,GAAA,YAAA;AAqBJ,IAAA,gBAAA,GAAmB,IAAM,eAAA,CAAgB,QAAQ;AAoBjD,IAAA,gBAAA,GAAmB,IAAM,eAAA,CAAgB,QAAQ;AA2CjD,IAAA,cAAA,GAAiB,IAAM,aAAA,CAAc,QAAQ;ACnE1D,IAAM,gCAAmC,GAAA;IACrC,QAAU,EAAA,kBAAA;IACV,IAAM,EAAA;AACV,CAAA;AAEA,SAAS,iBAAiB,IAAc,EAAA;IACpC,IAAI,IAAQ,IAAA,EAAA,CAAA,QAAA,OAAa,IAAQ,IAAA,EAAA,CAAA,QAAA,KAAA,OAAkB,IAAO,GAAA,EAAA,CAAA,QAAA;IAC1D,IAAI,QAAQ,EAAa,CAAA,QAAA,OAAA,IAAA,IAAQ,EAAW,CAAA,QAAA,KAAA,OAAO,OAAA,CAAQ,EAAY,CAAA,QAAA,MAAA,EAAA,CAAA;IACvE,IAAI,QAAQ,EAAa,CAAA,QAAA,OAAA,IAAA,IAAQ,GAAW,CAAA,QAAA,KAAA,OAAO,OAAA,CAAQ,EAAY,CAAA,QAAA,MAAA,EAAA,CAAA;AAC3E;AAqBa,IAAA,gBAAA,GAAmB,QAC5BC,gOAAc,EAAA;QACV,kBAAkB,CAAC,KAAA,GAAkB,KAAK,IAAK,CAAA,KAAA,CAAM,MAAA,GAAS,CAAC,CAAA;QAC/D,KAAA,EAAM,KAAe,EAAA,KAAA,EAAO,MAAQ,EAAA;YAChC,MAAM,MAAM,KAAM,CAAA,MAAA;YAClB,MAAM,KAAK,GAAM,GAAA,CAAA;YACjB,IAAI,QAAQ,CAAG,EAAA;gBACL,MAAA,CAAA,GAAI,KAAM,CAAA,UAAA,CAAW,CAAC,CAAA;gBACtB,MAAA,CAAA,GAAI,iBAAiB,CAAC,CAAA;gBAC5B,IAAI,MAAM,KAAA,CAAW,EAAA;oBACX,MAAA,IAAIC,sNAAAA,CAAYC,wPAA+C,EAAA;wBACjE,GAAG,gCAAA;wBACH;oBAAA,CACH,CAAA;gBAAA;gBAEL,KAAA,CAAM,GAAI,CAAA;oBAAC,CAAC;iBAAA,EAAG,MAAM,CAAA;gBACrB,OAAO,CAAI,GAAA,MAAA;YAAA;YAET,MAAA,QAAA,GAAW,IAAI,UAAA,CAAW,EAAE,CAAA;YAClC,IAAA,IAAS,IAAI,CAAG,EAAA,CAAA,GAAI,CAAG,EAAA,CAAA,GAAI,IAAI,CAAK,EAAA,CAAA;gBAC1B,MAAA,EAAA,GAAK,KAAM,CAAA,UAAA,CAAW,CAAG,EAAA,CAAA;gBACzB,MAAA,EAAA,GAAK,KAAM,CAAA,UAAA,CAAW,CAAG,EAAA,CAAA;gBAEzB,MAAA,EAAA,GAAK,iBAAiB,EAAE,CAAA;gBACxB,MAAA,EAAA,GAAK,iBAAiB,EAAE,CAAA;gBAC1B,IAAA,EAAA,KAAO,KAAA,KAAc,EAAO,KAAA,KAAA,CAAA,IAAa,CAAC,MAAO,CAAA,KAAA,CAAM,EAAE,CAAI,EAAA;oBACvD,MAAA,IAAID,sNAAAA,CAAYC,wPAA+C,EAAA;wBACjE,GAAG,gCAAA;wBACH;oBAAA,CACH,CAAA;gBAAA;gBAEI,QAAA,CAAA,CAAC,CAAI,GAAA,CAAC,MAAO,CAAA,KAAA,CAAM,EAAE,CAAK,GAAA,EAAA,IAAM,CAAM,GAAA,gBAAA,EAAA,mBAAM,CAAK,CAAA,GAAA,EAAA;YAAA;YAGxD,KAAA,CAAA,GAAA,CAAI,UAAU,MAAM,CAAA;YAC1B,OAAO,SAAS,MAAS,GAAA,MAAA;QAAA;IAEjC,CAAC;AAoBQ,IAAA,gBAAA,GAAmB,QAC5BC,gOAAc,EAAA;QACV,IAAA,EAAK,KAAA,EAAO,MAAQ,EAAA;YAChB,MAAM,QAAQ,KAAM,CAAA,KAAA,CAAM,MAAM,CAAE,CAAA,MAAA,CAAO,CAAC,GAAK,EAAA,IAAA,GAAS,GAAM,GAAA,IAAA,CAAK,QAAA,CAAS,EAAE,CAAA,CAAE,QAAA,CAAS,CAAG,EAAA,GAAG,GAAG,EAAE,CAAA;YAC7F,OAAA;gBAAC,KAAO;gBAAA,KAAA,CAAM,MAAM;aAAA;QAAA;IAEnC,CAAC;AA2CE,IAAM,iBAAiB,IAAiCC,mOAAAA,EAAa,gBAAiB,EAAA,EAAG,kBAAkB;;ACzJlH,IAAML,SAAW,GAAA,4DAAA;AAqBJ,IAAA,gBAAA,GAAmB,IAAM,eAAA,CAAgBA,SAAQ;AAoBjD,IAAA,gBAAA,GAAmB,IAAM,eAAA,CAAgBA,SAAQ;AA2CjD,IAAA,cAAA,GAAiB,IAAM,aAAA,CAAcA,SAAQ;ACpDnD,IAAM,sBAAyB,GAAA,CAACA,SAAkB,EAAA,IAAA,OACrDC,gOAAc,EAAA;QACV,gBAAA,EAAkB,CAAC,KAAkB,GAAA,IAAA,CAAK,KAAA,CAAO,KAAM,CAAA,MAAA,GAAS,OAAQ,CAAC,CAAA;QACzE,KAAA,EAAM,KAAe,EAAA,KAAA,EAAO,MAAQ,EAAA;YAChC,qBAAA,CAAsBD,WAAU,KAAK,CAAA;YACjC,IAAA,KAAA,KAAU,IAAW,OAAA,MAAA;YACnB,MAAA,WAAA,GAAc,CAAC;mBAAG,KAAK;aAAA,CAAE,GAAA,CAAI,CAAKA,CAAAA,GAAAA,SAAAA,CAAS,OAAQ,CAAA,CAAC,CAAC,CAAA;YAC3D,MAAM,aAAgB,GAAA,OAAA,CAAQ,WAAa,EAAA,IAAA,EAAM,GAAG,KAAK,CAAA;YACnD,KAAA,CAAA,GAAA,CAAI,eAAe,MAAM,CAAA;YAC/B,OAAO,cAAc,MAAS,GAAA,MAAA;QAAA;IAEtC,CAAC;AAyBE,IAAM,sBAAyB,GAAA,CAACA,SAAkB,EAAA,IAAA,OACrDI,gOAAc,EAAA;QACV,IAAA,EAAK,QAAU;yBAAA,MAAA,2DAAS,CAAqB,EAAA;YACzC,MAAM,QAAQ,MAAW,KAAA,CAAA,GAAI,QAAW,GAAA,QAAA,CAAS,KAAA,CAAM,MAAM,CAAA;YAC7D,IAAI,MAAM,MAAW,KAAA,CAAA,EAAA,OAAU;gBAAC,EAAA;gBAAI,SAAS,MAAM;aAAA;YAC7C,MAAA,WAAA,GAAc,QAAQ,CAAC;mBAAG,KAAK;aAAG,EAAA,CAAA,EAAG,MAAM,IAAI,CAAA;YACrD,OAAO;gBAAC,WAAA,CAAY,GAAI,CAAA,CAAA,CAAA,GAAKJ,SAAS,CAAA,CAAC,CAAC,CAAA,CAAE,IAAK,CAAA,EAAE,CAAG;gBAAA,QAAA,CAAS,MAAM;aAAA;QAAA;IAE3E,CAAC;AA+CE,IAAM,oBAAuB,GAAA,CAACA,SAAkB,EAAA,IAAA,GACnDK,mOAAa,EAAA,sBAAA,CAAuBL,SAAU,EAAA,IAAI,CAAG,EAAA,sBAAA,CAAuBA,SAAU,EAAA,IAAI,CAAC;AAG/F,SAAS,OAAQ,CAAA,KAAA,EAAiB,SAAmB,EAAA,UAAA,EAAoB,YAAiC,EAAA;IACtG,MAAM,SAAS,EAAC;IAChB,IAAI,WAAc,GAAA,CAAA;IAClB,IAAI,iBAAoB,GAAA,CAAA;IAClB,MAAA,IAAA,GAAA,CAAQ,KAAK,UAAc,IAAA,CAAA;IACjC,KAAA,MAAW,SAAS,KAAO,CAAA;QACvB,WAAA,GAAe,eAAe,SAAa,GAAA,KAAA;QACtB,iBAAA,IAAA,SAAA;QACrB,MAAO,qBAAqB,UAAY,CAAA;YACf,iBAAA,IAAA,UAAA;YACd,MAAA,CAAA,IAAA,CAAM,WAAe,IAAA,iBAAA,GAAqB,IAAI,CAAA;QAAA;IACzD;IAEA,IAAA,YAAA,IAAgB,oBAAoB,CAAG,EAAA;QACvC,MAAA,CAAO,IAAM,CAAA,WAAA,IAAgB,UAAa,GAAA,iBAAA,GAAsB,IAAI,CAAA;IAAA;IAEjE,OAAA,MAAA;AACX;;ACnIA,IAAMA,SAAW,GAAA,kEAAA;AAqBV,IAAM,mBAAmB,MAAmC;IAC9C;QACb,WAAOC,gOAAc,EAAA;YACjB,gBAAA,EAAkB,CAAC,KAAkB,KAAA;gBAC7B,IAAA;oBACQ,OAAA,IAAA,CAAwB,KAAK,CAAE,CAAA,MAAA;gBAAA,CACnC,CAAA,UAAA;oBACE,MAAA,IAAIC,sNAAAA,CAAYC,wPAA+C,EAAA;wBACjE,QAAAH,EAAAA,SAAAA;wBACA,IAAM,EAAA,EAAA;wBACN;oBAAA,CACH,CAAA;gBAAA;YACL,CACJ;YACA,KAAA,EAAM,KAAe,EAAA,KAAA,EAAO,MAAQ,EAAA;gBAC5B,IAAA;oBACA,MAAM,UAAc,GAAA,IAAA,CAAwB,KAAK,CAAA,CAC5C,KAAM,CAAA,EAAE,CACR,CAAA,GAAA,CAAI,CAAK,CAAA,GAAA,CAAA,CAAE,UAAW,CAAA,CAAC,CAAC,CAAA;oBACvB,KAAA,CAAA,GAAA,CAAI,YAAY,MAAM,CAAA;oBAC5B,OAAO,WAAW,MAAS,GAAA,MAAA;gBAAA,CACvB,CAAA,UAAA;oBACE,MAAA,IAAIE,sNAAAA,CAAYC,wPAA+C,EAAA;wBACjE,QAAAH,EAAAA,SAAAA;wBACA,IAAM,EAAA,EAAA;wBACN;oBAAA,CACH,CAAA;gBAAA;YACL;QACJ,CACH,CAAA;IAAA;AAgBT;AAoBO,IAAM,mBAAmB,MAAmC;IAC9C;QACb,WAAOI,gOAAc,EAAA;YACjB,IAAA,EAAK,KAAO;6BAAA,MAAA,2DAAS,CAAG,EAAA;gBACd,MAAA,KAAA,GAAQ,KAAM,CAAA,KAAA,CAAM,MAAM,CAAA;gBAChC,MAAM,QAAS,IAAwB,CAAA,MAAA,CAAO,YAAa,CAAA,GAAG,KAAK,CAAC,CAAA;gBAC7D,OAAA;oBAAC,KAAO;oBAAA,KAAA,CAAM,MAAM;iBAAA;YAAA;QAC/B,CACH,CAAA;IAAA;AAYT;AA2CO,IAAM,iBAAiB,QAAiCC,+NAAAA,EAAa,gBAAiB,EAAA,EAAG,kBAAkB;;ACrJ3G,IAAM,uBAAuB,CAAC,KAAA,GAAA,4CAAA;IAEjC,KAAA,CAAM,OAAQ,CAAA,SAAA,EAAW,EAAE;AAkBxB,IAAM,oBAAoB,CAAC,KAAA,EAAe,QAAkB,KAAM,CAAA,MAAA,CAAO,OAAO,IAAQ;;ACnCxF,IAAMC,IAAc,UAAW,CAAA,WAAA;AAA/B,IACMC,IAAc,UAAW,CAAA,WAAA;;AC8B/B,IAAM,iBAAiB,MAAmC;IACzD,IAAA,WAAA;IACJ,WAAON,gOAAc,EAAA;QACjB,gBAAA,EAAkB,CAAA,QAAA,iBAAU,WAAgB,GAAA,IAAI,IAAe,EAAA,MAAA,CAAO,KAAK,CAAE,CAAA,MAAA;QAC7E,KAAO,EAAA,CAAC,KAAe,EAAA,KAAA,EAAO,MAAW,KAAA;YACrC,MAAM,aAAA,iBAAc,WAAgB,GAAA,IAAI,CAAY,GAAA,EAAG,MAAA,CAAO,KAAK,CAAA;YAC7D,KAAA,CAAA,GAAA,CAAI,YAAY,MAAM,CAAA;YAC5B,OAAO,SAAS,UAAW,CAAA,MAAA;QAAA;IAC/B,CACH,CAAA;AACL;AAqBO,IAAM,iBAAiB,MAAmC;IACzD,IAAA,WAAA;IACJ,WAAOG,gOAAc,EAAA;QACjB,IAAA,EAAK,KAAA,EAAO,MAAQ,EAAA;YACV,MAAA,KAAA,GAAA,iBAAS,cAAgB,IAAI,CAAA,GAAA,EAAe,MAAO,CAAA,KAAA,CAAM,KAAM,CAAA,MAAM,CAAC,CAAA;YAC5E,OAAO;gBAAC,oBAAA,CAAqB,KAAK,CAAA;gBAAG,MAAM,MAAM;aAAA;QAAA;IACrD,CACH,CAAA;AACL;AA2CO,IAAM,eAAe,QAAiCC,+NAAAA,EAAa,cAAe,EAAA,EAAG,gBAAgB","debugId":null}},
    {"offset": {"line": 352, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/addresses/node_modules/@solana/codecs-strings/dist/index.browser.mjs","sources":["file:///Users/ivaylobakalov/web3/solana/voting-dapp/frontend/node_modules/%40solana/addresses/node_modules/%40solana/codecs-strings/src/assertions.ts","file:///Users/ivaylobakalov/web3/solana/voting-dapp/frontend/node_modules/%40solana/addresses/node_modules/%40solana/codecs-strings/src/baseX.ts","file:///Users/ivaylobakalov/web3/solana/voting-dapp/frontend/node_modules/%40solana/addresses/node_modules/%40solana/codecs-strings/src/base10.ts","file:///Users/ivaylobakalov/web3/solana/voting-dapp/frontend/node_modules/%40solana/addresses/node_modules/%40solana/codecs-strings/src/base16.ts","file:///Users/ivaylobakalov/web3/solana/voting-dapp/frontend/node_modules/%40solana/addresses/node_modules/%40solana/codecs-strings/src/base58.ts","file:///Users/ivaylobakalov/web3/solana/voting-dapp/frontend/node_modules/%40solana/addresses/node_modules/%40solana/codecs-strings/src/baseX-reslice.ts","file:///Users/ivaylobakalov/web3/solana/voting-dapp/frontend/node_modules/%40solana/addresses/node_modules/%40solana/codecs-strings/src/base64.ts","file:///Users/ivaylobakalov/web3/solana/voting-dapp/frontend/node_modules/%40solana/addresses/node_modules/%40solana/codecs-strings/src/null-characters.ts","file:///Users/ivaylobakalov/web3/solana/voting-dapp/frontend/node_modules/%40solana/addresses/node_modules/%40solana/text-encoding-impl/src/index.browser.ts","file:///Users/ivaylobakalov/web3/solana/voting-dapp/frontend/node_modules/%40solana/addresses/node_modules/%40solana/codecs-strings/src/utf8.ts"],"sourcesContent":["import { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\n/**\n * Asserts that a given string contains only characters from the specified alphabet.\n *\n * This function validates whether a string consists exclusively of characters\n * from the provided `alphabet`. If the validation fails, it throws an error\n * indicating the invalid base string.\n *\n * @param alphabet - The allowed set of characters for the base encoding.\n * @param testValue - The string to validate against the given alphabet.\n * @param givenValue - The original string provided by the user (defaults to `testValue`).\n *\n * @throws {SolanaError} If `testValue` contains characters not present in `alphabet`.\n *\n * @example\n * Validating a base-8 encoded string.\n * ```ts\n * assertValidBaseString('01234567', '123047'); // Passes\n * assertValidBaseString('01234567', '128');    // Throws error\n * ```\n */\nexport function assertValidBaseString(alphabet: string, testValue: string, givenValue = testValue) {\n    if (!testValue.match(new RegExp(`^[${alphabet}]*$`))) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n            alphabet,\n            base: alphabet.length,\n            value: givenValue,\n        });\n    }\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertValidBaseString } from './assertions';\n\n/**\n * Returns an encoder for base-X encoded strings.\n *\n * This encoder serializes strings using a custom alphabet, treating the length of the alphabet as the base.\n * The encoding process involves converting the input string to a numeric value in base-X, then\n * encoding that value into bytes while preserving leading zeroes.\n *\n * For more details, see {@link getBaseXCodec}.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @returns A `VariableSizeEncoder<string>` for encoding base-X strings.\n *\n * @example\n * Encoding a base-X string using a custom alphabet.\n * ```ts\n * const encoder = getBaseXEncoder('0123456789abcdef');\n * const bytes = encoder.encode('deadface'); // 0xdeadface\n * ```\n *\n * @see {@link getBaseXCodec}\n */\nexport const getBaseXEncoder = (alphabet: string): VariableSizeEncoder<string> => {\n    return createEncoder({\n        getSizeFromValue: (value: string): number => {\n            const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet[0]);\n            if (!tailChars) return value.length;\n\n            const base10Number = getBigIntFromBaseX(tailChars, alphabet);\n            return leadingZeroes.length + Math.ceil(base10Number.toString(16).length / 2);\n        },\n        write(value: string, bytes, offset) {\n            // Check if the value is valid.\n            assertValidBaseString(alphabet, value);\n            if (value === '') return offset;\n\n            // Handle leading zeroes.\n            const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet[0]);\n            if (!tailChars) {\n                bytes.set(new Uint8Array(leadingZeroes.length).fill(0), offset);\n                return offset + leadingZeroes.length;\n            }\n\n            // From baseX to base10.\n            let base10Number = getBigIntFromBaseX(tailChars, alphabet);\n\n            // From base10 to bytes.\n            const tailBytes: number[] = [];\n            while (base10Number > 0n) {\n                tailBytes.unshift(Number(base10Number % 256n));\n                base10Number /= 256n;\n            }\n\n            const bytesToAdd = [...Array(leadingZeroes.length).fill(0), ...tailBytes];\n            bytes.set(bytesToAdd, offset);\n            return offset + bytesToAdd.length;\n        },\n    });\n};\n\n/**\n * Returns a decoder for base-X encoded strings.\n *\n * This decoder deserializes base-X encoded strings from a byte array using a custom alphabet.\n * The decoding process converts the byte array into a numeric value in base-10, then\n * maps that value back to characters in the specified base-X alphabet.\n *\n * For more details, see {@link getBaseXCodec}.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @returns A `VariableSizeDecoder<string>` for decoding base-X strings.\n *\n * @example\n * Decoding a base-X string using a custom alphabet.\n * ```ts\n * const decoder = getBaseXDecoder('0123456789abcdef');\n * const value = decoder.decode(new Uint8Array([0xde, 0xad, 0xfa, 0xce])); // \"deadface\"\n * ```\n *\n * @see {@link getBaseXCodec}\n */\nexport const getBaseXDecoder = (alphabet: string): VariableSizeDecoder<string> => {\n    return createDecoder({\n        read(rawBytes, offset): [string, number] {\n            const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);\n            if (bytes.length === 0) return ['', 0];\n\n            // Handle leading zeroes.\n            let trailIndex = bytes.findIndex(n => n !== 0);\n            trailIndex = trailIndex === -1 ? bytes.length : trailIndex;\n            const leadingZeroes = alphabet[0].repeat(trailIndex);\n            if (trailIndex === bytes.length) return [leadingZeroes, rawBytes.length];\n\n            // From bytes to base10.\n            const base10Number = bytes.slice(trailIndex).reduce((sum, byte) => sum * 256n + BigInt(byte), 0n);\n\n            // From base10 to baseX.\n            const tailChars = getBaseXFromBigInt(base10Number, alphabet);\n\n            return [leadingZeroes + tailChars, rawBytes.length];\n        },\n    });\n};\n\n/**\n * Returns a codec for encoding and decoding base-X strings.\n *\n * This codec serializes strings using a custom alphabet, treating the length of the alphabet as the base.\n * The encoding process converts the input string into a numeric value in base-X, which is then encoded as bytes.\n * The decoding process reverses this transformation to reconstruct the original string.\n *\n * This codec supports leading zeroes by treating the first character of the alphabet as the zero character.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-X strings.\n *\n * @example\n * Encoding and decoding a base-X string using a custom alphabet.\n * ```ts\n * const codec = getBaseXCodec('0123456789abcdef');\n * const bytes = codec.encode('deadface'); // 0xdeadface\n * const value = codec.decode(bytes);      // \"deadface\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-X codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBaseXCodec('0123456789abcdef'), 8);\n * ```\n *\n * If you need a size-prefixed base-X codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBaseXCodec('0123456789abcdef'), getU32Codec());\n * ```\n *\n * Separate {@link getBaseXEncoder} and {@link getBaseXDecoder} functions are available.\n *\n * ```ts\n * const bytes = getBaseXEncoder('0123456789abcdef').encode('deadface');\n * const value = getBaseXDecoder('0123456789abcdef').decode(bytes);\n * ```\n *\n * @see {@link getBaseXEncoder}\n * @see {@link getBaseXDecoder}\n */\nexport const getBaseXCodec = (alphabet: string): VariableSizeCodec<string> =>\n    combineCodec(getBaseXEncoder(alphabet), getBaseXDecoder(alphabet));\n\nfunction partitionLeadingZeroes(\n    value: string,\n    zeroCharacter: string,\n): [leadingZeros: string, tailChars: string | undefined] {\n    const [leadingZeros, tailChars] = value.split(new RegExp(`((?!${zeroCharacter}).*)`));\n    return [leadingZeros, tailChars];\n}\n\nfunction getBigIntFromBaseX(value: string, alphabet: string): bigint {\n    const base = BigInt(alphabet.length);\n    let sum = 0n;\n    for (const char of value) {\n        sum *= base;\n        sum += BigInt(alphabet.indexOf(char));\n    }\n    return sum;\n}\n\nfunction getBaseXFromBigInt(value: bigint, alphabet: string): string {\n    const base = BigInt(alphabet.length);\n    const tailChars = [];\n    while (value > 0n) {\n        tailChars.unshift(alphabet[Number(value % base)]);\n        value /= base;\n    }\n    return tailChars.join('');\n}\n","import { getBaseXCodec, getBaseXDecoder, getBaseXEncoder } from './baseX';\n\nconst alphabet = '0123456789';\n\n/**\n * Returns an encoder for base-10 strings.\n *\n * This encoder serializes strings using a base-10 encoding scheme.\n * The output consists of bytes representing the numerical values of the input string.\n *\n * For more details, see {@link getBase10Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding base-10 strings.\n *\n * @example\n * Encoding a base-10 string.\n * ```ts\n * const encoder = getBase10Encoder();\n * const bytes = encoder.encode('1024'); // 0x0400\n * ```\n *\n * @see {@link getBase10Codec}\n */\nexport const getBase10Encoder = () => getBaseXEncoder(alphabet);\n\n/**\n * Returns a decoder for base-10 strings.\n *\n * This decoder deserializes base-10 encoded strings from a byte array.\n *\n * For more details, see {@link getBase10Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding base-10 strings.\n *\n * @example\n * Decoding a base-10 string.\n * ```ts\n * const decoder = getBase10Decoder();\n * const value = decoder.decode(new Uint8Array([0x04, 0x00])); // \"1024\"\n * ```\n *\n * @see {@link getBase10Codec}\n */\nexport const getBase10Decoder = () => getBaseXDecoder(alphabet);\n\n/**\n * Returns a codec for encoding and decoding base-10 strings.\n *\n * This codec serializes strings using a base-10 encoding scheme.\n * The output consists of bytes representing the numerical values of the input string.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-10 strings.\n *\n * @example\n * Encoding and decoding a base-10 string.\n * ```ts\n * const codec = getBase10Codec();\n * const bytes = codec.encode('1024'); // 0x0400\n * const value = codec.decode(bytes);  // \"1024\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-10 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBase10Codec(), 5);\n * ```\n *\n * If you need a size-prefixed base-10 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBase10Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getBase10Encoder} and {@link getBase10Decoder} functions are available.\n *\n * ```ts\n * const bytes = getBase10Encoder().encode('1024');\n * const value = getBase10Decoder().decode(bytes);\n * ```\n *\n * @see {@link getBase10Encoder}\n * @see {@link getBase10Decoder}\n */\nexport const getBase10Codec = () => getBaseXCodec(alphabet);\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\nconst enum HexC {\n    ZERO = 48, // 0\n    NINE = 57, // 9\n    A_UP = 65, // A\n    F_UP = 70, // F\n    A_LO = 97, // a\n    F_LO = 102, // f\n}\n\nconst INVALID_STRING_ERROR_BASE_CONFIG = {\n    alphabet: '0123456789abcdef',\n    base: 16,\n} as const;\n\nfunction charCodeToBase16(char: number) {\n    if (char >= HexC.ZERO && char <= HexC.NINE) return char - HexC.ZERO;\n    if (char >= HexC.A_UP && char <= HexC.F_UP) return char - (HexC.A_UP - 10);\n    if (char >= HexC.A_LO && char <= HexC.F_LO) return char - (HexC.A_LO - 10);\n}\n\n/**\n * Returns an encoder for base-16 (hexadecimal) strings.\n *\n * This encoder serializes strings using a base-16 encoding scheme.\n * The output consists of bytes representing the hexadecimal values of the input string.\n *\n * For more details, see {@link getBase16Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding base-16 strings.\n *\n * @example\n * Encoding a base-16 string.\n * ```ts\n * const encoder = getBase16Encoder();\n * const bytes = encoder.encode('deadface'); // 0xdeadface\n * ```\n *\n * @see {@link getBase16Codec}\n */\nexport const getBase16Encoder = (): VariableSizeEncoder<string> =>\n    createEncoder({\n        getSizeFromValue: (value: string) => Math.ceil(value.length / 2),\n        write(value: string, bytes, offset) {\n            const len = value.length;\n            const al = len / 2;\n            if (len === 1) {\n                const c = value.charCodeAt(0);\n                const n = charCodeToBase16(c);\n                if (n === undefined) {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        ...INVALID_STRING_ERROR_BASE_CONFIG,\n                        value,\n                    });\n                }\n                bytes.set([n], offset);\n                return 1 + offset;\n            }\n            const hexBytes = new Uint8Array(al);\n            for (let i = 0, j = 0; i < al; i++) {\n                const c1 = value.charCodeAt(j++);\n                const c2 = value.charCodeAt(j++);\n\n                const n1 = charCodeToBase16(c1);\n                const n2 = charCodeToBase16(c2);\n                if (n1 === undefined || (n2 === undefined && !Number.isNaN(c2))) {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        ...INVALID_STRING_ERROR_BASE_CONFIG,\n                        value,\n                    });\n                }\n                hexBytes[i] = !Number.isNaN(c2) ? (n1 << 4) | (n2 ?? 0) : n1;\n            }\n\n            bytes.set(hexBytes, offset);\n            return hexBytes.length + offset;\n        },\n    });\n\n/**\n * Returns a decoder for base-16 (hexadecimal) strings.\n *\n * This decoder deserializes base-16 encoded strings from a byte array.\n *\n * For more details, see {@link getBase16Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding base-16 strings.\n *\n * @example\n * Decoding a base-16 string.\n * ```ts\n * const decoder = getBase16Decoder();\n * const value = decoder.decode(new Uint8Array([0xde, 0xad, 0xfa, 0xce])); // \"deadface\"\n * ```\n *\n * @see {@link getBase16Codec}\n */\nexport const getBase16Decoder = (): VariableSizeDecoder<string> =>\n    createDecoder({\n        read(bytes, offset) {\n            const value = bytes.slice(offset).reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n            return [value, bytes.length];\n        },\n    });\n\n/**\n * Returns a codec for encoding and decoding base-16 (hexadecimal) strings.\n *\n * This codec serializes strings using a base-16 encoding scheme.\n * The output consists of bytes representing the hexadecimal values of the input string.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-16 strings.\n *\n * @example\n * Encoding and decoding a base-16 string.\n * ```ts\n * const codec = getBase16Codec();\n * const bytes = codec.encode('deadface'); // 0xdeadface\n * const value = codec.decode(bytes);      // \"deadface\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-16 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBase16Codec(), 8);\n * ```\n *\n * If you need a size-prefixed base-16 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBase16Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getBase16Encoder} and {@link getBase16Decoder} functions are available.\n *\n * ```ts\n * const bytes = getBase16Encoder().encode('deadface');\n * const value = getBase16Decoder().decode(bytes);\n * ```\n *\n * @see {@link getBase16Encoder}\n * @see {@link getBase16Decoder}\n */\nexport const getBase16Codec = (): VariableSizeCodec<string> => combineCodec(getBase16Encoder(), getBase16Decoder());\n","import { getBaseXCodec, getBaseXDecoder, getBaseXEncoder } from './baseX';\n\nconst alphabet = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\n\n/**\n * Returns an encoder for base-58 strings.\n *\n * This encoder serializes strings using a base-58 encoding scheme,\n * commonly used in cryptocurrency addresses and other compact representations.\n *\n * For more details, see {@link getBase58Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding base-58 strings.\n *\n * @example\n * Encoding a base-58 string.\n * ```ts\n * const encoder = getBase58Encoder();\n * const bytes = encoder.encode('heLLo'); // 0x1b6a3070\n * ```\n *\n * @see {@link getBase58Codec}\n */\nexport const getBase58Encoder = () => getBaseXEncoder(alphabet);\n\n/**\n * Returns a decoder for base-58 strings.\n *\n * This decoder deserializes base-58 encoded strings from a byte array.\n *\n * For more details, see {@link getBase58Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding base-58 strings.\n *\n * @example\n * Decoding a base-58 string.\n * ```ts\n * const decoder = getBase58Decoder();\n * const value = decoder.decode(new Uint8Array([0x1b, 0x6a, 0x30, 0x70])); // \"heLLo\"\n * ```\n *\n * @see {@link getBase58Codec}\n */\nexport const getBase58Decoder = () => getBaseXDecoder(alphabet);\n\n/**\n * Returns a codec for encoding and decoding base-58 strings.\n *\n * This codec serializes strings using a base-58 encoding scheme,\n * commonly used in cryptocurrency addresses and other compact representations.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-58 strings.\n *\n * @example\n * Encoding and decoding a base-58 string.\n * ```ts\n * const codec = getBase58Codec();\n * const bytes = codec.encode('heLLo'); // 0x1b6a3070\n * const value = codec.decode(bytes);   // \"heLLo\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-58 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBase58Codec(), 8);\n * ```\n *\n * If you need a size-prefixed base-58 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBase58Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getBase58Encoder} and {@link getBase58Decoder} functions are available.\n *\n * ```ts\n * const bytes = getBase58Encoder().encode('heLLo');\n * const value = getBase58Decoder().decode(bytes);\n * ```\n *\n * @see {@link getBase58Encoder}\n * @see {@link getBase58Decoder}\n */\nexport const getBase58Codec = () => getBaseXCodec(alphabet);\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertValidBaseString } from './assertions';\n\n/**\n * Returns an encoder for base-X encoded strings using bit re-slicing.\n *\n * This encoder serializes strings by dividing the input into custom-sized bit chunks,\n * mapping them to an alphabet, and encoding the result into a byte array.\n * This approach is commonly used for encoding schemes where the alphabet's length is a power of 2,\n * such as base-16 or base-64.\n *\n * For more details, see {@link getBaseXResliceCodec}.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @param bits - The number of bits per encoded chunk, typically `log2(alphabet.length)`.\n * @returns A `VariableSizeEncoder<string>` for encoding base-X strings using bit re-slicing.\n *\n * @example\n * Encoding a base-X string using bit re-slicing.\n * ```ts\n * const encoder = getBaseXResliceEncoder('elho', 2);\n * const bytes = encoder.encode('hellolol'); // 0x4aee\n * ```\n *\n * @see {@link getBaseXResliceCodec}\n */\nexport const getBaseXResliceEncoder = (alphabet: string, bits: number): VariableSizeEncoder<string> =>\n    createEncoder({\n        getSizeFromValue: (value: string) => Math.floor((value.length * bits) / 8),\n        write(value: string, bytes, offset) {\n            assertValidBaseString(alphabet, value);\n            if (value === '') return offset;\n            const charIndices = [...value].map(c => alphabet.indexOf(c));\n            const reslicedBytes = reslice(charIndices, bits, 8, false);\n            bytes.set(reslicedBytes, offset);\n            return reslicedBytes.length + offset;\n        },\n    });\n\n/**\n * Returns a decoder for base-X encoded strings using bit re-slicing.\n *\n * This decoder deserializes base-X encoded strings by re-slicing the bits of a byte array into\n * custom-sized chunks and mapping them to a specified alphabet.\n * This is typically used for encoding schemes where the alphabet's length is a power of 2,\n * such as base-16 or base-64.\n *\n * For more details, see {@link getBaseXResliceCodec}.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @param bits - The number of bits per encoded chunk, typically `log2(alphabet.length)`.\n * @returns A `VariableSizeDecoder<string>` for decoding base-X strings using bit re-slicing.\n *\n * @example\n * Decoding a base-X string using bit re-slicing.\n * ```ts\n * const decoder = getBaseXResliceDecoder('elho', 2);\n * const value = decoder.decode(new Uint8Array([0x4a, 0xee])); // \"hellolol\"\n * ```\n *\n * @see {@link getBaseXResliceCodec}\n */\nexport const getBaseXResliceDecoder = (alphabet: string, bits: number): VariableSizeDecoder<string> =>\n    createDecoder({\n        read(rawBytes, offset = 0): [string, number] {\n            const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);\n            if (bytes.length === 0) return ['', rawBytes.length];\n            const charIndices = reslice([...bytes], 8, bits, true);\n            return [charIndices.map(i => alphabet[i]).join(''), rawBytes.length];\n        },\n    });\n\n/**\n * Returns a codec for encoding and decoding base-X strings using bit re-slicing.\n *\n * This codec serializes strings by dividing the input into custom-sized bit chunks,\n * mapping them to a given alphabet, and encoding the result into bytes.\n * It is particularly suited for encoding schemes where the alphabet's length is a power of 2,\n * such as base-16 or base-64.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @param bits - The number of bits per encoded chunk, typically `log2(alphabet.length)`.\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-X strings using bit re-slicing.\n *\n * @example\n * Encoding and decoding a base-X string using bit re-slicing.\n * ```ts\n * const codec = getBaseXResliceCodec('elho', 2);\n * const bytes = codec.encode('hellolol'); // 0x4aee\n * const value = codec.decode(bytes);      // \"hellolol\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-X codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBaseXResliceCodec('elho', 2), 8);\n * ```\n *\n * If you need a size-prefixed base-X codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBaseXResliceCodec('elho', 2), getU32Codec());\n * ```\n *\n * Separate {@link getBaseXResliceEncoder} and {@link getBaseXResliceDecoder} functions are available.\n *\n * ```ts\n * const bytes = getBaseXResliceEncoder('elho', 2).encode('hellolol');\n * const value = getBaseXResliceDecoder('elho', 2).decode(bytes);\n * ```\n *\n * @see {@link getBaseXResliceEncoder}\n * @see {@link getBaseXResliceDecoder}\n */\nexport const getBaseXResliceCodec = (alphabet: string, bits: number): VariableSizeCodec<string> =>\n    combineCodec(getBaseXResliceEncoder(alphabet, bits), getBaseXResliceDecoder(alphabet, bits));\n\n/** Helper function to reslice the bits inside bytes. */\nfunction reslice(input: number[], inputBits: number, outputBits: number, useRemainder: boolean): number[] {\n    const output = [];\n    let accumulator = 0;\n    let bitsInAccumulator = 0;\n    const mask = (1 << outputBits) - 1;\n    for (const value of input) {\n        accumulator = (accumulator << inputBits) | value;\n        bitsInAccumulator += inputBits;\n        while (bitsInAccumulator >= outputBits) {\n            bitsInAccumulator -= outputBits;\n            output.push((accumulator >> bitsInAccumulator) & mask);\n        }\n    }\n    if (useRemainder && bitsInAccumulator > 0) {\n        output.push((accumulator << (outputBits - bitsInAccumulator)) & mask);\n    }\n    return output;\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\nimport { assertValidBaseString } from './assertions';\nimport { getBaseXResliceDecoder, getBaseXResliceEncoder } from './baseX-reslice';\n\nconst alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n/**\n * Returns an encoder for base-64 strings.\n *\n * This encoder serializes strings using a base-64 encoding scheme,\n * commonly used for data encoding in URLs, cryptographic keys, and binary-to-text encoding.\n *\n * For more details, see {@link getBase64Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding base-64 strings.\n *\n * @example\n * Encoding a base-64 string.\n * ```ts\n * const encoder = getBase64Encoder();\n * const bytes = encoder.encode('hello+world'); // 0x85e965a3ec28ae57\n * ```\n *\n * @see {@link getBase64Codec}\n */\nexport const getBase64Encoder = (): VariableSizeEncoder<string> => {\n    if (__BROWSER__) {\n        return createEncoder({\n            getSizeFromValue: (value: string) => {\n                try {\n                    return (atob as Window['atob'])(value).length;\n                } catch {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        alphabet,\n                        base: 64,\n                        value,\n                    });\n                }\n            },\n            write(value: string, bytes, offset) {\n                try {\n                    const bytesToAdd = (atob as Window['atob'])(value)\n                        .split('')\n                        .map(c => c.charCodeAt(0));\n                    bytes.set(bytesToAdd, offset);\n                    return bytesToAdd.length + offset;\n                } catch {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        alphabet,\n                        base: 64,\n                        value,\n                    });\n                }\n            },\n        });\n    }\n\n    if (__NODEJS__) {\n        return createEncoder({\n            getSizeFromValue: (value: string) => Buffer.from(value, 'base64').length,\n            write(value: string, bytes, offset) {\n                assertValidBaseString(alphabet, value.replace(/=/g, ''));\n                const buffer = Buffer.from(value, 'base64');\n                bytes.set(buffer, offset);\n                return buffer.length + offset;\n            },\n        });\n    }\n\n    return transformEncoder(getBaseXResliceEncoder(alphabet, 6), (value: string): string => value.replace(/=/g, ''));\n};\n\n/**\n * Returns a decoder for base-64 strings.\n *\n * This decoder deserializes base-64 encoded strings from a byte array.\n *\n * For more details, see {@link getBase64Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding base-64 strings.\n *\n * @example\n * Decoding a base-64 string.\n * ```ts\n * const decoder = getBase64Decoder();\n * const value = decoder.decode(new Uint8Array([0x85, 0xe9, 0x65, 0xa3, 0xec, 0x28, 0xae, 0x57])); // \"hello+world\"\n * ```\n *\n * @see {@link getBase64Codec}\n */\nexport const getBase64Decoder = (): VariableSizeDecoder<string> => {\n    if (__BROWSER__) {\n        return createDecoder({\n            read(bytes, offset = 0) {\n                const slice = bytes.slice(offset);\n                const value = (btoa as Window['btoa'])(String.fromCharCode(...slice));\n                return [value, bytes.length];\n            },\n        });\n    }\n\n    if (__NODEJS__) {\n        return createDecoder({\n            read: (bytes, offset = 0) => [Buffer.from(bytes, offset).toString('base64'), bytes.length],\n        });\n    }\n\n    return transformDecoder(getBaseXResliceDecoder(alphabet, 6), (value: string): string =>\n        value.padEnd(Math.ceil(value.length / 4) * 4, '='),\n    );\n};\n\n/**\n * Returns a codec for encoding and decoding base-64 strings.\n *\n * This codec serializes strings using a base-64 encoding scheme,\n * commonly used for data encoding in URLs, cryptographic keys, and binary-to-text encoding.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-64 strings.\n *\n * @example\n * Encoding and decoding a base-64 string.\n * ```ts\n * const codec = getBase64Codec();\n * const bytes = codec.encode('hello+world'); // 0x85e965a3ec28ae57\n * const value = codec.decode(bytes);         // \"hello+world\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-64 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBase64Codec(), 8);\n * ```\n *\n * If you need a size-prefixed base-64 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBase64Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getBase64Encoder} and {@link getBase64Decoder} functions are available.\n *\n * ```ts\n * const bytes = getBase64Encoder().encode('hello+world');\n * const value = getBase64Decoder().decode(bytes);\n * ```\n *\n * @see {@link getBase64Encoder}\n * @see {@link getBase64Decoder}\n */\nexport const getBase64Codec = (): VariableSizeCodec<string> => combineCodec(getBase64Encoder(), getBase64Decoder());\n","/**\n * Removes all null characters (`\\u0000`) from a string.\n *\n * This function cleans a string by stripping out any null characters,\n * which are often used as padding in fixed-size string encodings.\n *\n * @param value - The string to process.\n * @returns The input string with all null characters removed.\n *\n * @example\n * Removing null characters from a string.\n * ```ts\n * removeNullCharacters('hello\\u0000\\u0000'); // \"hello\"\n * ```\n */\nexport const removeNullCharacters = (value: string) =>\n    // eslint-disable-next-line no-control-regex\n    value.replace(/\\u0000/g, '');\n\n/**\n * Pads a string with null characters (`\\u0000`) at the end to reach a fixed length.\n *\n * If the input string is shorter than the specified length, it is padded with null characters\n * until it reaches the desired size. If it is already long enough, it remains unchanged.\n *\n * @param value - The string to pad.\n * @param chars - The total length of the resulting string, including padding.\n * @returns The input string padded with null characters up to the specified length.\n *\n * @example\n * Padding a string with null characters.\n * ```ts\n * padNullCharacters('hello', 8); // \"hello\\u0000\\u0000\\u0000\"\n * ```\n */\nexport const padNullCharacters = (value: string, chars: number) => value.padEnd(chars, '\\u0000');\n","export const TextDecoder = globalThis.TextDecoder;\nexport const TextEncoder = globalThis.TextEncoder;\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { TextDecoder, TextEncoder } from '@solana/text-encoding-impl';\n\nimport { removeNullCharacters } from './null-characters';\n\n/**\n * Returns an encoder for UTF-8 strings.\n *\n * This encoder serializes strings using UTF-8 encoding.\n * The encoded output contains as many bytes as needed to represent the string.\n *\n * For more details, see {@link getUtf8Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding UTF-8 strings.\n *\n * @example\n * Encoding a UTF-8 string.\n * ```ts\n * const encoder = getUtf8Encoder();\n * const bytes = encoder.encode('hello'); // 0x68656c6c6f\n * ```\n *\n * @see {@link getUtf8Codec}\n */\nexport const getUtf8Encoder = (): VariableSizeEncoder<string> => {\n    let textEncoder: TextEncoder;\n    return createEncoder({\n        getSizeFromValue: value => (textEncoder ||= new TextEncoder()).encode(value).length,\n        write: (value: string, bytes, offset) => {\n            const bytesToAdd = (textEncoder ||= new TextEncoder()).encode(value);\n            bytes.set(bytesToAdd, offset);\n            return offset + bytesToAdd.length;\n        },\n    });\n};\n\n/**\n * Returns a decoder for UTF-8 strings.\n *\n * This decoder deserializes UTF-8 encoded strings from a byte array.\n * It reads all available bytes starting from the given offset.\n *\n * For more details, see {@link getUtf8Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding UTF-8 strings.\n *\n * @example\n * Decoding a UTF-8 string.\n * ```ts\n * const decoder = getUtf8Decoder();\n * const value = decoder.decode(new Uint8Array([0x68, 0x65, 0x6c, 0x6c, 0x6f])); // \"hello\"\n * ```\n *\n * @see {@link getUtf8Codec}\n */\nexport const getUtf8Decoder = (): VariableSizeDecoder<string> => {\n    let textDecoder: TextDecoder;\n    return createDecoder({\n        read(bytes, offset) {\n            const value = (textDecoder ||= new TextDecoder()).decode(bytes.slice(offset));\n            return [removeNullCharacters(value), bytes.length];\n        },\n    });\n};\n\n/**\n * Returns a codec for encoding and decoding UTF-8 strings.\n *\n * This codec serializes strings using UTF-8 encoding.\n * The encoded output contains as many bytes as needed to represent the string.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding UTF-8 strings.\n *\n * @example\n * Encoding and decoding a UTF-8 string.\n * ```ts\n * const codec = getUtf8Codec();\n * const bytes = codec.encode('hello'); // 0x68656c6c6f\n * const value = codec.decode(bytes);   // \"hello\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size UTF-8 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getUtf8Codec(), 5);\n * ```\n *\n * If you need a size-prefixed UTF-8 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getUtf8Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getUtf8Encoder} and {@link getUtf8Decoder} functions are available.\n *\n * ```ts\n * const bytes = getUtf8Encoder().encode('hello');\n * const value = getUtf8Decoder().decode(bytes);\n * ```\n *\n * @see {@link getUtf8Encoder}\n * @see {@link getUtf8Decoder}\n */\nexport const getUtf8Codec = (): VariableSizeCodec<string> => combineCodec(getUtf8Encoder(), getUtf8Decoder());\n"],"names":["alphabet","createEncoder","SolanaError","SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE","createDecoder","combineCodec","TextDecoder","TextEncoder"],"mappings":"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","debugId":null}},
    {"offset": {"line": 700, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/keys/node_modules/@solana/codecs-strings/dist/index.browser.mjs","sources":["file:///Users/ivaylobakalov/web3/solana/voting-dapp/frontend/node_modules/%40solana/keys/node_modules/%40solana/codecs-strings/src/assertions.ts","file:///Users/ivaylobakalov/web3/solana/voting-dapp/frontend/node_modules/%40solana/keys/node_modules/%40solana/codecs-strings/src/baseX.ts","file:///Users/ivaylobakalov/web3/solana/voting-dapp/frontend/node_modules/%40solana/keys/node_modules/%40solana/codecs-strings/src/base10.ts","file:///Users/ivaylobakalov/web3/solana/voting-dapp/frontend/node_modules/%40solana/keys/node_modules/%40solana/codecs-strings/src/base16.ts","file:///Users/ivaylobakalov/web3/solana/voting-dapp/frontend/node_modules/%40solana/keys/node_modules/%40solana/codecs-strings/src/base58.ts","file:///Users/ivaylobakalov/web3/solana/voting-dapp/frontend/node_modules/%40solana/keys/node_modules/%40solana/codecs-strings/src/baseX-reslice.ts","file:///Users/ivaylobakalov/web3/solana/voting-dapp/frontend/node_modules/%40solana/keys/node_modules/%40solana/codecs-strings/src/base64.ts","file:///Users/ivaylobakalov/web3/solana/voting-dapp/frontend/node_modules/%40solana/keys/node_modules/%40solana/codecs-strings/src/null-characters.ts","file:///Users/ivaylobakalov/web3/solana/voting-dapp/frontend/node_modules/%40solana/keys/node_modules/%40solana/text-encoding-impl/src/index.browser.ts","file:///Users/ivaylobakalov/web3/solana/voting-dapp/frontend/node_modules/%40solana/keys/node_modules/%40solana/codecs-strings/src/utf8.ts"],"sourcesContent":["import { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\n/**\n * Asserts that a given string contains only characters from the specified alphabet.\n *\n * This function validates whether a string consists exclusively of characters\n * from the provided `alphabet`. If the validation fails, it throws an error\n * indicating the invalid base string.\n *\n * @param alphabet - The allowed set of characters for the base encoding.\n * @param testValue - The string to validate against the given alphabet.\n * @param givenValue - The original string provided by the user (defaults to `testValue`).\n *\n * @throws {SolanaError} If `testValue` contains characters not present in `alphabet`.\n *\n * @example\n * Validating a base-8 encoded string.\n * ```ts\n * assertValidBaseString('01234567', '123047'); // Passes\n * assertValidBaseString('01234567', '128');    // Throws error\n * ```\n */\nexport function assertValidBaseString(alphabet: string, testValue: string, givenValue = testValue) {\n    if (!testValue.match(new RegExp(`^[${alphabet}]*$`))) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n            alphabet,\n            base: alphabet.length,\n            value: givenValue,\n        });\n    }\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertValidBaseString } from './assertions';\n\n/**\n * Returns an encoder for base-X encoded strings.\n *\n * This encoder serializes strings using a custom alphabet, treating the length of the alphabet as the base.\n * The encoding process involves converting the input string to a numeric value in base-X, then\n * encoding that value into bytes while preserving leading zeroes.\n *\n * For more details, see {@link getBaseXCodec}.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @returns A `VariableSizeEncoder<string>` for encoding base-X strings.\n *\n * @example\n * Encoding a base-X string using a custom alphabet.\n * ```ts\n * const encoder = getBaseXEncoder('0123456789abcdef');\n * const bytes = encoder.encode('deadface'); // 0xdeadface\n * ```\n *\n * @see {@link getBaseXCodec}\n */\nexport const getBaseXEncoder = (alphabet: string): VariableSizeEncoder<string> => {\n    return createEncoder({\n        getSizeFromValue: (value: string): number => {\n            const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet[0]);\n            if (!tailChars) return value.length;\n\n            const base10Number = getBigIntFromBaseX(tailChars, alphabet);\n            return leadingZeroes.length + Math.ceil(base10Number.toString(16).length / 2);\n        },\n        write(value: string, bytes, offset) {\n            // Check if the value is valid.\n            assertValidBaseString(alphabet, value);\n            if (value === '') return offset;\n\n            // Handle leading zeroes.\n            const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet[0]);\n            if (!tailChars) {\n                bytes.set(new Uint8Array(leadingZeroes.length).fill(0), offset);\n                return offset + leadingZeroes.length;\n            }\n\n            // From baseX to base10.\n            let base10Number = getBigIntFromBaseX(tailChars, alphabet);\n\n            // From base10 to bytes.\n            const tailBytes: number[] = [];\n            while (base10Number > 0n) {\n                tailBytes.unshift(Number(base10Number % 256n));\n                base10Number /= 256n;\n            }\n\n            const bytesToAdd = [...Array(leadingZeroes.length).fill(0), ...tailBytes];\n            bytes.set(bytesToAdd, offset);\n            return offset + bytesToAdd.length;\n        },\n    });\n};\n\n/**\n * Returns a decoder for base-X encoded strings.\n *\n * This decoder deserializes base-X encoded strings from a byte array using a custom alphabet.\n * The decoding process converts the byte array into a numeric value in base-10, then\n * maps that value back to characters in the specified base-X alphabet.\n *\n * For more details, see {@link getBaseXCodec}.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @returns A `VariableSizeDecoder<string>` for decoding base-X strings.\n *\n * @example\n * Decoding a base-X string using a custom alphabet.\n * ```ts\n * const decoder = getBaseXDecoder('0123456789abcdef');\n * const value = decoder.decode(new Uint8Array([0xde, 0xad, 0xfa, 0xce])); // \"deadface\"\n * ```\n *\n * @see {@link getBaseXCodec}\n */\nexport const getBaseXDecoder = (alphabet: string): VariableSizeDecoder<string> => {\n    return createDecoder({\n        read(rawBytes, offset): [string, number] {\n            const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);\n            if (bytes.length === 0) return ['', 0];\n\n            // Handle leading zeroes.\n            let trailIndex = bytes.findIndex(n => n !== 0);\n            trailIndex = trailIndex === -1 ? bytes.length : trailIndex;\n            const leadingZeroes = alphabet[0].repeat(trailIndex);\n            if (trailIndex === bytes.length) return [leadingZeroes, rawBytes.length];\n\n            // From bytes to base10.\n            const base10Number = bytes.slice(trailIndex).reduce((sum, byte) => sum * 256n + BigInt(byte), 0n);\n\n            // From base10 to baseX.\n            const tailChars = getBaseXFromBigInt(base10Number, alphabet);\n\n            return [leadingZeroes + tailChars, rawBytes.length];\n        },\n    });\n};\n\n/**\n * Returns a codec for encoding and decoding base-X strings.\n *\n * This codec serializes strings using a custom alphabet, treating the length of the alphabet as the base.\n * The encoding process converts the input string into a numeric value in base-X, which is then encoded as bytes.\n * The decoding process reverses this transformation to reconstruct the original string.\n *\n * This codec supports leading zeroes by treating the first character of the alphabet as the zero character.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-X strings.\n *\n * @example\n * Encoding and decoding a base-X string using a custom alphabet.\n * ```ts\n * const codec = getBaseXCodec('0123456789abcdef');\n * const bytes = codec.encode('deadface'); // 0xdeadface\n * const value = codec.decode(bytes);      // \"deadface\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-X codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBaseXCodec('0123456789abcdef'), 8);\n * ```\n *\n * If you need a size-prefixed base-X codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBaseXCodec('0123456789abcdef'), getU32Codec());\n * ```\n *\n * Separate {@link getBaseXEncoder} and {@link getBaseXDecoder} functions are available.\n *\n * ```ts\n * const bytes = getBaseXEncoder('0123456789abcdef').encode('deadface');\n * const value = getBaseXDecoder('0123456789abcdef').decode(bytes);\n * ```\n *\n * @see {@link getBaseXEncoder}\n * @see {@link getBaseXDecoder}\n */\nexport const getBaseXCodec = (alphabet: string): VariableSizeCodec<string> =>\n    combineCodec(getBaseXEncoder(alphabet), getBaseXDecoder(alphabet));\n\nfunction partitionLeadingZeroes(\n    value: string,\n    zeroCharacter: string,\n): [leadingZeros: string, tailChars: string | undefined] {\n    const [leadingZeros, tailChars] = value.split(new RegExp(`((?!${zeroCharacter}).*)`));\n    return [leadingZeros, tailChars];\n}\n\nfunction getBigIntFromBaseX(value: string, alphabet: string): bigint {\n    const base = BigInt(alphabet.length);\n    let sum = 0n;\n    for (const char of value) {\n        sum *= base;\n        sum += BigInt(alphabet.indexOf(char));\n    }\n    return sum;\n}\n\nfunction getBaseXFromBigInt(value: bigint, alphabet: string): string {\n    const base = BigInt(alphabet.length);\n    const tailChars = [];\n    while (value > 0n) {\n        tailChars.unshift(alphabet[Number(value % base)]);\n        value /= base;\n    }\n    return tailChars.join('');\n}\n","import { getBaseXCodec, getBaseXDecoder, getBaseXEncoder } from './baseX';\n\nconst alphabet = '0123456789';\n\n/**\n * Returns an encoder for base-10 strings.\n *\n * This encoder serializes strings using a base-10 encoding scheme.\n * The output consists of bytes representing the numerical values of the input string.\n *\n * For more details, see {@link getBase10Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding base-10 strings.\n *\n * @example\n * Encoding a base-10 string.\n * ```ts\n * const encoder = getBase10Encoder();\n * const bytes = encoder.encode('1024'); // 0x0400\n * ```\n *\n * @see {@link getBase10Codec}\n */\nexport const getBase10Encoder = () => getBaseXEncoder(alphabet);\n\n/**\n * Returns a decoder for base-10 strings.\n *\n * This decoder deserializes base-10 encoded strings from a byte array.\n *\n * For more details, see {@link getBase10Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding base-10 strings.\n *\n * @example\n * Decoding a base-10 string.\n * ```ts\n * const decoder = getBase10Decoder();\n * const value = decoder.decode(new Uint8Array([0x04, 0x00])); // \"1024\"\n * ```\n *\n * @see {@link getBase10Codec}\n */\nexport const getBase10Decoder = () => getBaseXDecoder(alphabet);\n\n/**\n * Returns a codec for encoding and decoding base-10 strings.\n *\n * This codec serializes strings using a base-10 encoding scheme.\n * The output consists of bytes representing the numerical values of the input string.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-10 strings.\n *\n * @example\n * Encoding and decoding a base-10 string.\n * ```ts\n * const codec = getBase10Codec();\n * const bytes = codec.encode('1024'); // 0x0400\n * const value = codec.decode(bytes);  // \"1024\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-10 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBase10Codec(), 5);\n * ```\n *\n * If you need a size-prefixed base-10 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBase10Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getBase10Encoder} and {@link getBase10Decoder} functions are available.\n *\n * ```ts\n * const bytes = getBase10Encoder().encode('1024');\n * const value = getBase10Decoder().decode(bytes);\n * ```\n *\n * @see {@link getBase10Encoder}\n * @see {@link getBase10Decoder}\n */\nexport const getBase10Codec = () => getBaseXCodec(alphabet);\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\nconst enum HexC {\n    ZERO = 48, // 0\n    NINE = 57, // 9\n    A_UP = 65, // A\n    F_UP = 70, // F\n    A_LO = 97, // a\n    F_LO = 102, // f\n}\n\nconst INVALID_STRING_ERROR_BASE_CONFIG = {\n    alphabet: '0123456789abcdef',\n    base: 16,\n} as const;\n\nfunction charCodeToBase16(char: number) {\n    if (char >= HexC.ZERO && char <= HexC.NINE) return char - HexC.ZERO;\n    if (char >= HexC.A_UP && char <= HexC.F_UP) return char - (HexC.A_UP - 10);\n    if (char >= HexC.A_LO && char <= HexC.F_LO) return char - (HexC.A_LO - 10);\n}\n\n/**\n * Returns an encoder for base-16 (hexadecimal) strings.\n *\n * This encoder serializes strings using a base-16 encoding scheme.\n * The output consists of bytes representing the hexadecimal values of the input string.\n *\n * For more details, see {@link getBase16Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding base-16 strings.\n *\n * @example\n * Encoding a base-16 string.\n * ```ts\n * const encoder = getBase16Encoder();\n * const bytes = encoder.encode('deadface'); // 0xdeadface\n * ```\n *\n * @see {@link getBase16Codec}\n */\nexport const getBase16Encoder = (): VariableSizeEncoder<string> =>\n    createEncoder({\n        getSizeFromValue: (value: string) => Math.ceil(value.length / 2),\n        write(value: string, bytes, offset) {\n            const len = value.length;\n            const al = len / 2;\n            if (len === 1) {\n                const c = value.charCodeAt(0);\n                const n = charCodeToBase16(c);\n                if (n === undefined) {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        ...INVALID_STRING_ERROR_BASE_CONFIG,\n                        value,\n                    });\n                }\n                bytes.set([n], offset);\n                return 1 + offset;\n            }\n            const hexBytes = new Uint8Array(al);\n            for (let i = 0, j = 0; i < al; i++) {\n                const c1 = value.charCodeAt(j++);\n                const c2 = value.charCodeAt(j++);\n\n                const n1 = charCodeToBase16(c1);\n                const n2 = charCodeToBase16(c2);\n                if (n1 === undefined || (n2 === undefined && !Number.isNaN(c2))) {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        ...INVALID_STRING_ERROR_BASE_CONFIG,\n                        value,\n                    });\n                }\n                hexBytes[i] = !Number.isNaN(c2) ? (n1 << 4) | (n2 ?? 0) : n1;\n            }\n\n            bytes.set(hexBytes, offset);\n            return hexBytes.length + offset;\n        },\n    });\n\n/**\n * Returns a decoder for base-16 (hexadecimal) strings.\n *\n * This decoder deserializes base-16 encoded strings from a byte array.\n *\n * For more details, see {@link getBase16Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding base-16 strings.\n *\n * @example\n * Decoding a base-16 string.\n * ```ts\n * const decoder = getBase16Decoder();\n * const value = decoder.decode(new Uint8Array([0xde, 0xad, 0xfa, 0xce])); // \"deadface\"\n * ```\n *\n * @see {@link getBase16Codec}\n */\nexport const getBase16Decoder = (): VariableSizeDecoder<string> =>\n    createDecoder({\n        read(bytes, offset) {\n            const value = bytes.slice(offset).reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n            return [value, bytes.length];\n        },\n    });\n\n/**\n * Returns a codec for encoding and decoding base-16 (hexadecimal) strings.\n *\n * This codec serializes strings using a base-16 encoding scheme.\n * The output consists of bytes representing the hexadecimal values of the input string.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-16 strings.\n *\n * @example\n * Encoding and decoding a base-16 string.\n * ```ts\n * const codec = getBase16Codec();\n * const bytes = codec.encode('deadface'); // 0xdeadface\n * const value = codec.decode(bytes);      // \"deadface\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-16 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBase16Codec(), 8);\n * ```\n *\n * If you need a size-prefixed base-16 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBase16Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getBase16Encoder} and {@link getBase16Decoder} functions are available.\n *\n * ```ts\n * const bytes = getBase16Encoder().encode('deadface');\n * const value = getBase16Decoder().decode(bytes);\n * ```\n *\n * @see {@link getBase16Encoder}\n * @see {@link getBase16Decoder}\n */\nexport const getBase16Codec = (): VariableSizeCodec<string> => combineCodec(getBase16Encoder(), getBase16Decoder());\n","import { getBaseXCodec, getBaseXDecoder, getBaseXEncoder } from './baseX';\n\nconst alphabet = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\n\n/**\n * Returns an encoder for base-58 strings.\n *\n * This encoder serializes strings using a base-58 encoding scheme,\n * commonly used in cryptocurrency addresses and other compact representations.\n *\n * For more details, see {@link getBase58Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding base-58 strings.\n *\n * @example\n * Encoding a base-58 string.\n * ```ts\n * const encoder = getBase58Encoder();\n * const bytes = encoder.encode('heLLo'); // 0x1b6a3070\n * ```\n *\n * @see {@link getBase58Codec}\n */\nexport const getBase58Encoder = () => getBaseXEncoder(alphabet);\n\n/**\n * Returns a decoder for base-58 strings.\n *\n * This decoder deserializes base-58 encoded strings from a byte array.\n *\n * For more details, see {@link getBase58Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding base-58 strings.\n *\n * @example\n * Decoding a base-58 string.\n * ```ts\n * const decoder = getBase58Decoder();\n * const value = decoder.decode(new Uint8Array([0x1b, 0x6a, 0x30, 0x70])); // \"heLLo\"\n * ```\n *\n * @see {@link getBase58Codec}\n */\nexport const getBase58Decoder = () => getBaseXDecoder(alphabet);\n\n/**\n * Returns a codec for encoding and decoding base-58 strings.\n *\n * This codec serializes strings using a base-58 encoding scheme,\n * commonly used in cryptocurrency addresses and other compact representations.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-58 strings.\n *\n * @example\n * Encoding and decoding a base-58 string.\n * ```ts\n * const codec = getBase58Codec();\n * const bytes = codec.encode('heLLo'); // 0x1b6a3070\n * const value = codec.decode(bytes);   // \"heLLo\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-58 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBase58Codec(), 8);\n * ```\n *\n * If you need a size-prefixed base-58 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBase58Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getBase58Encoder} and {@link getBase58Decoder} functions are available.\n *\n * ```ts\n * const bytes = getBase58Encoder().encode('heLLo');\n * const value = getBase58Decoder().decode(bytes);\n * ```\n *\n * @see {@link getBase58Encoder}\n * @see {@link getBase58Decoder}\n */\nexport const getBase58Codec = () => getBaseXCodec(alphabet);\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertValidBaseString } from './assertions';\n\n/**\n * Returns an encoder for base-X encoded strings using bit re-slicing.\n *\n * This encoder serializes strings by dividing the input into custom-sized bit chunks,\n * mapping them to an alphabet, and encoding the result into a byte array.\n * This approach is commonly used for encoding schemes where the alphabet's length is a power of 2,\n * such as base-16 or base-64.\n *\n * For more details, see {@link getBaseXResliceCodec}.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @param bits - The number of bits per encoded chunk, typically `log2(alphabet.length)`.\n * @returns A `VariableSizeEncoder<string>` for encoding base-X strings using bit re-slicing.\n *\n * @example\n * Encoding a base-X string using bit re-slicing.\n * ```ts\n * const encoder = getBaseXResliceEncoder('elho', 2);\n * const bytes = encoder.encode('hellolol'); // 0x4aee\n * ```\n *\n * @see {@link getBaseXResliceCodec}\n */\nexport const getBaseXResliceEncoder = (alphabet: string, bits: number): VariableSizeEncoder<string> =>\n    createEncoder({\n        getSizeFromValue: (value: string) => Math.floor((value.length * bits) / 8),\n        write(value: string, bytes, offset) {\n            assertValidBaseString(alphabet, value);\n            if (value === '') return offset;\n            const charIndices = [...value].map(c => alphabet.indexOf(c));\n            const reslicedBytes = reslice(charIndices, bits, 8, false);\n            bytes.set(reslicedBytes, offset);\n            return reslicedBytes.length + offset;\n        },\n    });\n\n/**\n * Returns a decoder for base-X encoded strings using bit re-slicing.\n *\n * This decoder deserializes base-X encoded strings by re-slicing the bits of a byte array into\n * custom-sized chunks and mapping them to a specified alphabet.\n * This is typically used for encoding schemes where the alphabet's length is a power of 2,\n * such as base-16 or base-64.\n *\n * For more details, see {@link getBaseXResliceCodec}.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @param bits - The number of bits per encoded chunk, typically `log2(alphabet.length)`.\n * @returns A `VariableSizeDecoder<string>` for decoding base-X strings using bit re-slicing.\n *\n * @example\n * Decoding a base-X string using bit re-slicing.\n * ```ts\n * const decoder = getBaseXResliceDecoder('elho', 2);\n * const value = decoder.decode(new Uint8Array([0x4a, 0xee])); // \"hellolol\"\n * ```\n *\n * @see {@link getBaseXResliceCodec}\n */\nexport const getBaseXResliceDecoder = (alphabet: string, bits: number): VariableSizeDecoder<string> =>\n    createDecoder({\n        read(rawBytes, offset = 0): [string, number] {\n            const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);\n            if (bytes.length === 0) return ['', rawBytes.length];\n            const charIndices = reslice([...bytes], 8, bits, true);\n            return [charIndices.map(i => alphabet[i]).join(''), rawBytes.length];\n        },\n    });\n\n/**\n * Returns a codec for encoding and decoding base-X strings using bit re-slicing.\n *\n * This codec serializes strings by dividing the input into custom-sized bit chunks,\n * mapping them to a given alphabet, and encoding the result into bytes.\n * It is particularly suited for encoding schemes where the alphabet's length is a power of 2,\n * such as base-16 or base-64.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @param bits - The number of bits per encoded chunk, typically `log2(alphabet.length)`.\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-X strings using bit re-slicing.\n *\n * @example\n * Encoding and decoding a base-X string using bit re-slicing.\n * ```ts\n * const codec = getBaseXResliceCodec('elho', 2);\n * const bytes = codec.encode('hellolol'); // 0x4aee\n * const value = codec.decode(bytes);      // \"hellolol\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-X codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBaseXResliceCodec('elho', 2), 8);\n * ```\n *\n * If you need a size-prefixed base-X codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBaseXResliceCodec('elho', 2), getU32Codec());\n * ```\n *\n * Separate {@link getBaseXResliceEncoder} and {@link getBaseXResliceDecoder} functions are available.\n *\n * ```ts\n * const bytes = getBaseXResliceEncoder('elho', 2).encode('hellolol');\n * const value = getBaseXResliceDecoder('elho', 2).decode(bytes);\n * ```\n *\n * @see {@link getBaseXResliceEncoder}\n * @see {@link getBaseXResliceDecoder}\n */\nexport const getBaseXResliceCodec = (alphabet: string, bits: number): VariableSizeCodec<string> =>\n    combineCodec(getBaseXResliceEncoder(alphabet, bits), getBaseXResliceDecoder(alphabet, bits));\n\n/** Helper function to reslice the bits inside bytes. */\nfunction reslice(input: number[], inputBits: number, outputBits: number, useRemainder: boolean): number[] {\n    const output = [];\n    let accumulator = 0;\n    let bitsInAccumulator = 0;\n    const mask = (1 << outputBits) - 1;\n    for (const value of input) {\n        accumulator = (accumulator << inputBits) | value;\n        bitsInAccumulator += inputBits;\n        while (bitsInAccumulator >= outputBits) {\n            bitsInAccumulator -= outputBits;\n            output.push((accumulator >> bitsInAccumulator) & mask);\n        }\n    }\n    if (useRemainder && bitsInAccumulator > 0) {\n        output.push((accumulator << (outputBits - bitsInAccumulator)) & mask);\n    }\n    return output;\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\nimport { assertValidBaseString } from './assertions';\nimport { getBaseXResliceDecoder, getBaseXResliceEncoder } from './baseX-reslice';\n\nconst alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n/**\n * Returns an encoder for base-64 strings.\n *\n * This encoder serializes strings using a base-64 encoding scheme,\n * commonly used for data encoding in URLs, cryptographic keys, and binary-to-text encoding.\n *\n * For more details, see {@link getBase64Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding base-64 strings.\n *\n * @example\n * Encoding a base-64 string.\n * ```ts\n * const encoder = getBase64Encoder();\n * const bytes = encoder.encode('hello+world'); // 0x85e965a3ec28ae57\n * ```\n *\n * @see {@link getBase64Codec}\n */\nexport const getBase64Encoder = (): VariableSizeEncoder<string> => {\n    if (__BROWSER__) {\n        return createEncoder({\n            getSizeFromValue: (value: string) => {\n                try {\n                    return (atob as Window['atob'])(value).length;\n                } catch {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        alphabet,\n                        base: 64,\n                        value,\n                    });\n                }\n            },\n            write(value: string, bytes, offset) {\n                try {\n                    const bytesToAdd = (atob as Window['atob'])(value)\n                        .split('')\n                        .map(c => c.charCodeAt(0));\n                    bytes.set(bytesToAdd, offset);\n                    return bytesToAdd.length + offset;\n                } catch {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        alphabet,\n                        base: 64,\n                        value,\n                    });\n                }\n            },\n        });\n    }\n\n    if (__NODEJS__) {\n        return createEncoder({\n            getSizeFromValue: (value: string) => Buffer.from(value, 'base64').length,\n            write(value: string, bytes, offset) {\n                assertValidBaseString(alphabet, value.replace(/=/g, ''));\n                const buffer = Buffer.from(value, 'base64');\n                bytes.set(buffer, offset);\n                return buffer.length + offset;\n            },\n        });\n    }\n\n    return transformEncoder(getBaseXResliceEncoder(alphabet, 6), (value: string): string => value.replace(/=/g, ''));\n};\n\n/**\n * Returns a decoder for base-64 strings.\n *\n * This decoder deserializes base-64 encoded strings from a byte array.\n *\n * For more details, see {@link getBase64Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding base-64 strings.\n *\n * @example\n * Decoding a base-64 string.\n * ```ts\n * const decoder = getBase64Decoder();\n * const value = decoder.decode(new Uint8Array([0x85, 0xe9, 0x65, 0xa3, 0xec, 0x28, 0xae, 0x57])); // \"hello+world\"\n * ```\n *\n * @see {@link getBase64Codec}\n */\nexport const getBase64Decoder = (): VariableSizeDecoder<string> => {\n    if (__BROWSER__) {\n        return createDecoder({\n            read(bytes, offset = 0) {\n                const slice = bytes.slice(offset);\n                const value = (btoa as Window['btoa'])(String.fromCharCode(...slice));\n                return [value, bytes.length];\n            },\n        });\n    }\n\n    if (__NODEJS__) {\n        return createDecoder({\n            read: (bytes, offset = 0) => [Buffer.from(bytes, offset).toString('base64'), bytes.length],\n        });\n    }\n\n    return transformDecoder(getBaseXResliceDecoder(alphabet, 6), (value: string): string =>\n        value.padEnd(Math.ceil(value.length / 4) * 4, '='),\n    );\n};\n\n/**\n * Returns a codec for encoding and decoding base-64 strings.\n *\n * This codec serializes strings using a base-64 encoding scheme,\n * commonly used for data encoding in URLs, cryptographic keys, and binary-to-text encoding.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-64 strings.\n *\n * @example\n * Encoding and decoding a base-64 string.\n * ```ts\n * const codec = getBase64Codec();\n * const bytes = codec.encode('hello+world'); // 0x85e965a3ec28ae57\n * const value = codec.decode(bytes);         // \"hello+world\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-64 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBase64Codec(), 8);\n * ```\n *\n * If you need a size-prefixed base-64 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBase64Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getBase64Encoder} and {@link getBase64Decoder} functions are available.\n *\n * ```ts\n * const bytes = getBase64Encoder().encode('hello+world');\n * const value = getBase64Decoder().decode(bytes);\n * ```\n *\n * @see {@link getBase64Encoder}\n * @see {@link getBase64Decoder}\n */\nexport const getBase64Codec = (): VariableSizeCodec<string> => combineCodec(getBase64Encoder(), getBase64Decoder());\n","/**\n * Removes all null characters (`\\u0000`) from a string.\n *\n * This function cleans a string by stripping out any null characters,\n * which are often used as padding in fixed-size string encodings.\n *\n * @param value - The string to process.\n * @returns The input string with all null characters removed.\n *\n * @example\n * Removing null characters from a string.\n * ```ts\n * removeNullCharacters('hello\\u0000\\u0000'); // \"hello\"\n * ```\n */\nexport const removeNullCharacters = (value: string) =>\n    // eslint-disable-next-line no-control-regex\n    value.replace(/\\u0000/g, '');\n\n/**\n * Pads a string with null characters (`\\u0000`) at the end to reach a fixed length.\n *\n * If the input string is shorter than the specified length, it is padded with null characters\n * until it reaches the desired size. If it is already long enough, it remains unchanged.\n *\n * @param value - The string to pad.\n * @param chars - The total length of the resulting string, including padding.\n * @returns The input string padded with null characters up to the specified length.\n *\n * @example\n * Padding a string with null characters.\n * ```ts\n * padNullCharacters('hello', 8); // \"hello\\u0000\\u0000\\u0000\"\n * ```\n */\nexport const padNullCharacters = (value: string, chars: number) => value.padEnd(chars, '\\u0000');\n","export const TextDecoder = globalThis.TextDecoder;\nexport const TextEncoder = globalThis.TextEncoder;\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { TextDecoder, TextEncoder } from '@solana/text-encoding-impl';\n\nimport { removeNullCharacters } from './null-characters';\n\n/**\n * Returns an encoder for UTF-8 strings.\n *\n * This encoder serializes strings using UTF-8 encoding.\n * The encoded output contains as many bytes as needed to represent the string.\n *\n * For more details, see {@link getUtf8Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding UTF-8 strings.\n *\n * @example\n * Encoding a UTF-8 string.\n * ```ts\n * const encoder = getUtf8Encoder();\n * const bytes = encoder.encode('hello'); // 0x68656c6c6f\n * ```\n *\n * @see {@link getUtf8Codec}\n */\nexport const getUtf8Encoder = (): VariableSizeEncoder<string> => {\n    let textEncoder: TextEncoder;\n    return createEncoder({\n        getSizeFromValue: value => (textEncoder ||= new TextEncoder()).encode(value).length,\n        write: (value: string, bytes, offset) => {\n            const bytesToAdd = (textEncoder ||= new TextEncoder()).encode(value);\n            bytes.set(bytesToAdd, offset);\n            return offset + bytesToAdd.length;\n        },\n    });\n};\n\n/**\n * Returns a decoder for UTF-8 strings.\n *\n * This decoder deserializes UTF-8 encoded strings from a byte array.\n * It reads all available bytes starting from the given offset.\n *\n * For more details, see {@link getUtf8Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding UTF-8 strings.\n *\n * @example\n * Decoding a UTF-8 string.\n * ```ts\n * const decoder = getUtf8Decoder();\n * const value = decoder.decode(new Uint8Array([0x68, 0x65, 0x6c, 0x6c, 0x6f])); // \"hello\"\n * ```\n *\n * @see {@link getUtf8Codec}\n */\nexport const getUtf8Decoder = (): VariableSizeDecoder<string> => {\n    let textDecoder: TextDecoder;\n    return createDecoder({\n        read(bytes, offset) {\n            const value = (textDecoder ||= new TextDecoder()).decode(bytes.slice(offset));\n            return [removeNullCharacters(value), bytes.length];\n        },\n    });\n};\n\n/**\n * Returns a codec for encoding and decoding UTF-8 strings.\n *\n * This codec serializes strings using UTF-8 encoding.\n * The encoded output contains as many bytes as needed to represent the string.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding UTF-8 strings.\n *\n * @example\n * Encoding and decoding a UTF-8 string.\n * ```ts\n * const codec = getUtf8Codec();\n * const bytes = codec.encode('hello'); // 0x68656c6c6f\n * const value = codec.decode(bytes);   // \"hello\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size UTF-8 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getUtf8Codec(), 5);\n * ```\n *\n * If you need a size-prefixed UTF-8 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getUtf8Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getUtf8Encoder} and {@link getUtf8Decoder} functions are available.\n *\n * ```ts\n * const bytes = getUtf8Encoder().encode('hello');\n * const value = getUtf8Decoder().decode(bytes);\n * ```\n *\n * @see {@link getUtf8Encoder}\n * @see {@link getUtf8Decoder}\n */\nexport const getUtf8Codec = (): VariableSizeCodec<string> => combineCodec(getUtf8Encoder(), getUtf8Decoder());\n"],"names":["alphabet","createEncoder","SolanaError","SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE","createDecoder","combineCodec","TextDecoder","TextEncoder"],"mappings":"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","debugId":null}},
    {"offset": {"line": 1048, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/transactions/node_modules/@solana/codecs-strings/dist/index.browser.mjs","sources":["file:///Users/ivaylobakalov/web3/solana/voting-dapp/frontend/node_modules/%40solana/transactions/node_modules/%40solana/codecs-strings/src/assertions.ts","file:///Users/ivaylobakalov/web3/solana/voting-dapp/frontend/node_modules/%40solana/transactions/node_modules/%40solana/codecs-strings/src/baseX.ts","file:///Users/ivaylobakalov/web3/solana/voting-dapp/frontend/node_modules/%40solana/transactions/node_modules/%40solana/codecs-strings/src/base10.ts","file:///Users/ivaylobakalov/web3/solana/voting-dapp/frontend/node_modules/%40solana/transactions/node_modules/%40solana/codecs-strings/src/base16.ts","file:///Users/ivaylobakalov/web3/solana/voting-dapp/frontend/node_modules/%40solana/transactions/node_modules/%40solana/codecs-strings/src/base58.ts","file:///Users/ivaylobakalov/web3/solana/voting-dapp/frontend/node_modules/%40solana/transactions/node_modules/%40solana/codecs-strings/src/baseX-reslice.ts","file:///Users/ivaylobakalov/web3/solana/voting-dapp/frontend/node_modules/%40solana/transactions/node_modules/%40solana/codecs-strings/src/base64.ts","file:///Users/ivaylobakalov/web3/solana/voting-dapp/frontend/node_modules/%40solana/transactions/node_modules/%40solana/codecs-strings/src/null-characters.ts","file:///Users/ivaylobakalov/web3/solana/voting-dapp/frontend/node_modules/%40solana/transactions/node_modules/%40solana/text-encoding-impl/src/index.browser.ts","file:///Users/ivaylobakalov/web3/solana/voting-dapp/frontend/node_modules/%40solana/transactions/node_modules/%40solana/codecs-strings/src/utf8.ts"],"sourcesContent":["import { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\n/**\n * Asserts that a given string contains only characters from the specified alphabet.\n *\n * This function validates whether a string consists exclusively of characters\n * from the provided `alphabet`. If the validation fails, it throws an error\n * indicating the invalid base string.\n *\n * @param alphabet - The allowed set of characters for the base encoding.\n * @param testValue - The string to validate against the given alphabet.\n * @param givenValue - The original string provided by the user (defaults to `testValue`).\n *\n * @throws {SolanaError} If `testValue` contains characters not present in `alphabet`.\n *\n * @example\n * Validating a base-8 encoded string.\n * ```ts\n * assertValidBaseString('01234567', '123047'); // Passes\n * assertValidBaseString('01234567', '128');    // Throws error\n * ```\n */\nexport function assertValidBaseString(alphabet: string, testValue: string, givenValue = testValue) {\n    if (!testValue.match(new RegExp(`^[${alphabet}]*$`))) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n            alphabet,\n            base: alphabet.length,\n            value: givenValue,\n        });\n    }\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertValidBaseString } from './assertions';\n\n/**\n * Returns an encoder for base-X encoded strings.\n *\n * This encoder serializes strings using a custom alphabet, treating the length of the alphabet as the base.\n * The encoding process involves converting the input string to a numeric value in base-X, then\n * encoding that value into bytes while preserving leading zeroes.\n *\n * For more details, see {@link getBaseXCodec}.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @returns A `VariableSizeEncoder<string>` for encoding base-X strings.\n *\n * @example\n * Encoding a base-X string using a custom alphabet.\n * ```ts\n * const encoder = getBaseXEncoder('0123456789abcdef');\n * const bytes = encoder.encode('deadface'); // 0xdeadface\n * ```\n *\n * @see {@link getBaseXCodec}\n */\nexport const getBaseXEncoder = (alphabet: string): VariableSizeEncoder<string> => {\n    return createEncoder({\n        getSizeFromValue: (value: string): number => {\n            const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet[0]);\n            if (!tailChars) return value.length;\n\n            const base10Number = getBigIntFromBaseX(tailChars, alphabet);\n            return leadingZeroes.length + Math.ceil(base10Number.toString(16).length / 2);\n        },\n        write(value: string, bytes, offset) {\n            // Check if the value is valid.\n            assertValidBaseString(alphabet, value);\n            if (value === '') return offset;\n\n            // Handle leading zeroes.\n            const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet[0]);\n            if (!tailChars) {\n                bytes.set(new Uint8Array(leadingZeroes.length).fill(0), offset);\n                return offset + leadingZeroes.length;\n            }\n\n            // From baseX to base10.\n            let base10Number = getBigIntFromBaseX(tailChars, alphabet);\n\n            // From base10 to bytes.\n            const tailBytes: number[] = [];\n            while (base10Number > 0n) {\n                tailBytes.unshift(Number(base10Number % 256n));\n                base10Number /= 256n;\n            }\n\n            const bytesToAdd = [...Array(leadingZeroes.length).fill(0), ...tailBytes];\n            bytes.set(bytesToAdd, offset);\n            return offset + bytesToAdd.length;\n        },\n    });\n};\n\n/**\n * Returns a decoder for base-X encoded strings.\n *\n * This decoder deserializes base-X encoded strings from a byte array using a custom alphabet.\n * The decoding process converts the byte array into a numeric value in base-10, then\n * maps that value back to characters in the specified base-X alphabet.\n *\n * For more details, see {@link getBaseXCodec}.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @returns A `VariableSizeDecoder<string>` for decoding base-X strings.\n *\n * @example\n * Decoding a base-X string using a custom alphabet.\n * ```ts\n * const decoder = getBaseXDecoder('0123456789abcdef');\n * const value = decoder.decode(new Uint8Array([0xde, 0xad, 0xfa, 0xce])); // \"deadface\"\n * ```\n *\n * @see {@link getBaseXCodec}\n */\nexport const getBaseXDecoder = (alphabet: string): VariableSizeDecoder<string> => {\n    return createDecoder({\n        read(rawBytes, offset): [string, number] {\n            const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);\n            if (bytes.length === 0) return ['', 0];\n\n            // Handle leading zeroes.\n            let trailIndex = bytes.findIndex(n => n !== 0);\n            trailIndex = trailIndex === -1 ? bytes.length : trailIndex;\n            const leadingZeroes = alphabet[0].repeat(trailIndex);\n            if (trailIndex === bytes.length) return [leadingZeroes, rawBytes.length];\n\n            // From bytes to base10.\n            const base10Number = bytes.slice(trailIndex).reduce((sum, byte) => sum * 256n + BigInt(byte), 0n);\n\n            // From base10 to baseX.\n            const tailChars = getBaseXFromBigInt(base10Number, alphabet);\n\n            return [leadingZeroes + tailChars, rawBytes.length];\n        },\n    });\n};\n\n/**\n * Returns a codec for encoding and decoding base-X strings.\n *\n * This codec serializes strings using a custom alphabet, treating the length of the alphabet as the base.\n * The encoding process converts the input string into a numeric value in base-X, which is then encoded as bytes.\n * The decoding process reverses this transformation to reconstruct the original string.\n *\n * This codec supports leading zeroes by treating the first character of the alphabet as the zero character.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-X strings.\n *\n * @example\n * Encoding and decoding a base-X string using a custom alphabet.\n * ```ts\n * const codec = getBaseXCodec('0123456789abcdef');\n * const bytes = codec.encode('deadface'); // 0xdeadface\n * const value = codec.decode(bytes);      // \"deadface\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-X codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBaseXCodec('0123456789abcdef'), 8);\n * ```\n *\n * If you need a size-prefixed base-X codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBaseXCodec('0123456789abcdef'), getU32Codec());\n * ```\n *\n * Separate {@link getBaseXEncoder} and {@link getBaseXDecoder} functions are available.\n *\n * ```ts\n * const bytes = getBaseXEncoder('0123456789abcdef').encode('deadface');\n * const value = getBaseXDecoder('0123456789abcdef').decode(bytes);\n * ```\n *\n * @see {@link getBaseXEncoder}\n * @see {@link getBaseXDecoder}\n */\nexport const getBaseXCodec = (alphabet: string): VariableSizeCodec<string> =>\n    combineCodec(getBaseXEncoder(alphabet), getBaseXDecoder(alphabet));\n\nfunction partitionLeadingZeroes(\n    value: string,\n    zeroCharacter: string,\n): [leadingZeros: string, tailChars: string | undefined] {\n    const [leadingZeros, tailChars] = value.split(new RegExp(`((?!${zeroCharacter}).*)`));\n    return [leadingZeros, tailChars];\n}\n\nfunction getBigIntFromBaseX(value: string, alphabet: string): bigint {\n    const base = BigInt(alphabet.length);\n    let sum = 0n;\n    for (const char of value) {\n        sum *= base;\n        sum += BigInt(alphabet.indexOf(char));\n    }\n    return sum;\n}\n\nfunction getBaseXFromBigInt(value: bigint, alphabet: string): string {\n    const base = BigInt(alphabet.length);\n    const tailChars = [];\n    while (value > 0n) {\n        tailChars.unshift(alphabet[Number(value % base)]);\n        value /= base;\n    }\n    return tailChars.join('');\n}\n","import { getBaseXCodec, getBaseXDecoder, getBaseXEncoder } from './baseX';\n\nconst alphabet = '0123456789';\n\n/**\n * Returns an encoder for base-10 strings.\n *\n * This encoder serializes strings using a base-10 encoding scheme.\n * The output consists of bytes representing the numerical values of the input string.\n *\n * For more details, see {@link getBase10Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding base-10 strings.\n *\n * @example\n * Encoding a base-10 string.\n * ```ts\n * const encoder = getBase10Encoder();\n * const bytes = encoder.encode('1024'); // 0x0400\n * ```\n *\n * @see {@link getBase10Codec}\n */\nexport const getBase10Encoder = () => getBaseXEncoder(alphabet);\n\n/**\n * Returns a decoder for base-10 strings.\n *\n * This decoder deserializes base-10 encoded strings from a byte array.\n *\n * For more details, see {@link getBase10Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding base-10 strings.\n *\n * @example\n * Decoding a base-10 string.\n * ```ts\n * const decoder = getBase10Decoder();\n * const value = decoder.decode(new Uint8Array([0x04, 0x00])); // \"1024\"\n * ```\n *\n * @see {@link getBase10Codec}\n */\nexport const getBase10Decoder = () => getBaseXDecoder(alphabet);\n\n/**\n * Returns a codec for encoding and decoding base-10 strings.\n *\n * This codec serializes strings using a base-10 encoding scheme.\n * The output consists of bytes representing the numerical values of the input string.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-10 strings.\n *\n * @example\n * Encoding and decoding a base-10 string.\n * ```ts\n * const codec = getBase10Codec();\n * const bytes = codec.encode('1024'); // 0x0400\n * const value = codec.decode(bytes);  // \"1024\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-10 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBase10Codec(), 5);\n * ```\n *\n * If you need a size-prefixed base-10 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBase10Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getBase10Encoder} and {@link getBase10Decoder} functions are available.\n *\n * ```ts\n * const bytes = getBase10Encoder().encode('1024');\n * const value = getBase10Decoder().decode(bytes);\n * ```\n *\n * @see {@link getBase10Encoder}\n * @see {@link getBase10Decoder}\n */\nexport const getBase10Codec = () => getBaseXCodec(alphabet);\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\nconst enum HexC {\n    ZERO = 48, // 0\n    NINE = 57, // 9\n    A_UP = 65, // A\n    F_UP = 70, // F\n    A_LO = 97, // a\n    F_LO = 102, // f\n}\n\nconst INVALID_STRING_ERROR_BASE_CONFIG = {\n    alphabet: '0123456789abcdef',\n    base: 16,\n} as const;\n\nfunction charCodeToBase16(char: number) {\n    if (char >= HexC.ZERO && char <= HexC.NINE) return char - HexC.ZERO;\n    if (char >= HexC.A_UP && char <= HexC.F_UP) return char - (HexC.A_UP - 10);\n    if (char >= HexC.A_LO && char <= HexC.F_LO) return char - (HexC.A_LO - 10);\n}\n\n/**\n * Returns an encoder for base-16 (hexadecimal) strings.\n *\n * This encoder serializes strings using a base-16 encoding scheme.\n * The output consists of bytes representing the hexadecimal values of the input string.\n *\n * For more details, see {@link getBase16Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding base-16 strings.\n *\n * @example\n * Encoding a base-16 string.\n * ```ts\n * const encoder = getBase16Encoder();\n * const bytes = encoder.encode('deadface'); // 0xdeadface\n * ```\n *\n * @see {@link getBase16Codec}\n */\nexport const getBase16Encoder = (): VariableSizeEncoder<string> =>\n    createEncoder({\n        getSizeFromValue: (value: string) => Math.ceil(value.length / 2),\n        write(value: string, bytes, offset) {\n            const len = value.length;\n            const al = len / 2;\n            if (len === 1) {\n                const c = value.charCodeAt(0);\n                const n = charCodeToBase16(c);\n                if (n === undefined) {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        ...INVALID_STRING_ERROR_BASE_CONFIG,\n                        value,\n                    });\n                }\n                bytes.set([n], offset);\n                return 1 + offset;\n            }\n            const hexBytes = new Uint8Array(al);\n            for (let i = 0, j = 0; i < al; i++) {\n                const c1 = value.charCodeAt(j++);\n                const c2 = value.charCodeAt(j++);\n\n                const n1 = charCodeToBase16(c1);\n                const n2 = charCodeToBase16(c2);\n                if (n1 === undefined || (n2 === undefined && !Number.isNaN(c2))) {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        ...INVALID_STRING_ERROR_BASE_CONFIG,\n                        value,\n                    });\n                }\n                hexBytes[i] = !Number.isNaN(c2) ? (n1 << 4) | (n2 ?? 0) : n1;\n            }\n\n            bytes.set(hexBytes, offset);\n            return hexBytes.length + offset;\n        },\n    });\n\n/**\n * Returns a decoder for base-16 (hexadecimal) strings.\n *\n * This decoder deserializes base-16 encoded strings from a byte array.\n *\n * For more details, see {@link getBase16Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding base-16 strings.\n *\n * @example\n * Decoding a base-16 string.\n * ```ts\n * const decoder = getBase16Decoder();\n * const value = decoder.decode(new Uint8Array([0xde, 0xad, 0xfa, 0xce])); // \"deadface\"\n * ```\n *\n * @see {@link getBase16Codec}\n */\nexport const getBase16Decoder = (): VariableSizeDecoder<string> =>\n    createDecoder({\n        read(bytes, offset) {\n            const value = bytes.slice(offset).reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n            return [value, bytes.length];\n        },\n    });\n\n/**\n * Returns a codec for encoding and decoding base-16 (hexadecimal) strings.\n *\n * This codec serializes strings using a base-16 encoding scheme.\n * The output consists of bytes representing the hexadecimal values of the input string.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-16 strings.\n *\n * @example\n * Encoding and decoding a base-16 string.\n * ```ts\n * const codec = getBase16Codec();\n * const bytes = codec.encode('deadface'); // 0xdeadface\n * const value = codec.decode(bytes);      // \"deadface\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-16 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBase16Codec(), 8);\n * ```\n *\n * If you need a size-prefixed base-16 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBase16Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getBase16Encoder} and {@link getBase16Decoder} functions are available.\n *\n * ```ts\n * const bytes = getBase16Encoder().encode('deadface');\n * const value = getBase16Decoder().decode(bytes);\n * ```\n *\n * @see {@link getBase16Encoder}\n * @see {@link getBase16Decoder}\n */\nexport const getBase16Codec = (): VariableSizeCodec<string> => combineCodec(getBase16Encoder(), getBase16Decoder());\n","import { getBaseXCodec, getBaseXDecoder, getBaseXEncoder } from './baseX';\n\nconst alphabet = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\n\n/**\n * Returns an encoder for base-58 strings.\n *\n * This encoder serializes strings using a base-58 encoding scheme,\n * commonly used in cryptocurrency addresses and other compact representations.\n *\n * For more details, see {@link getBase58Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding base-58 strings.\n *\n * @example\n * Encoding a base-58 string.\n * ```ts\n * const encoder = getBase58Encoder();\n * const bytes = encoder.encode('heLLo'); // 0x1b6a3070\n * ```\n *\n * @see {@link getBase58Codec}\n */\nexport const getBase58Encoder = () => getBaseXEncoder(alphabet);\n\n/**\n * Returns a decoder for base-58 strings.\n *\n * This decoder deserializes base-58 encoded strings from a byte array.\n *\n * For more details, see {@link getBase58Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding base-58 strings.\n *\n * @example\n * Decoding a base-58 string.\n * ```ts\n * const decoder = getBase58Decoder();\n * const value = decoder.decode(new Uint8Array([0x1b, 0x6a, 0x30, 0x70])); // \"heLLo\"\n * ```\n *\n * @see {@link getBase58Codec}\n */\nexport const getBase58Decoder = () => getBaseXDecoder(alphabet);\n\n/**\n * Returns a codec for encoding and decoding base-58 strings.\n *\n * This codec serializes strings using a base-58 encoding scheme,\n * commonly used in cryptocurrency addresses and other compact representations.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-58 strings.\n *\n * @example\n * Encoding and decoding a base-58 string.\n * ```ts\n * const codec = getBase58Codec();\n * const bytes = codec.encode('heLLo'); // 0x1b6a3070\n * const value = codec.decode(bytes);   // \"heLLo\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-58 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBase58Codec(), 8);\n * ```\n *\n * If you need a size-prefixed base-58 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBase58Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getBase58Encoder} and {@link getBase58Decoder} functions are available.\n *\n * ```ts\n * const bytes = getBase58Encoder().encode('heLLo');\n * const value = getBase58Decoder().decode(bytes);\n * ```\n *\n * @see {@link getBase58Encoder}\n * @see {@link getBase58Decoder}\n */\nexport const getBase58Codec = () => getBaseXCodec(alphabet);\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertValidBaseString } from './assertions';\n\n/**\n * Returns an encoder for base-X encoded strings using bit re-slicing.\n *\n * This encoder serializes strings by dividing the input into custom-sized bit chunks,\n * mapping them to an alphabet, and encoding the result into a byte array.\n * This approach is commonly used for encoding schemes where the alphabet's length is a power of 2,\n * such as base-16 or base-64.\n *\n * For more details, see {@link getBaseXResliceCodec}.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @param bits - The number of bits per encoded chunk, typically `log2(alphabet.length)`.\n * @returns A `VariableSizeEncoder<string>` for encoding base-X strings using bit re-slicing.\n *\n * @example\n * Encoding a base-X string using bit re-slicing.\n * ```ts\n * const encoder = getBaseXResliceEncoder('elho', 2);\n * const bytes = encoder.encode('hellolol'); // 0x4aee\n * ```\n *\n * @see {@link getBaseXResliceCodec}\n */\nexport const getBaseXResliceEncoder = (alphabet: string, bits: number): VariableSizeEncoder<string> =>\n    createEncoder({\n        getSizeFromValue: (value: string) => Math.floor((value.length * bits) / 8),\n        write(value: string, bytes, offset) {\n            assertValidBaseString(alphabet, value);\n            if (value === '') return offset;\n            const charIndices = [...value].map(c => alphabet.indexOf(c));\n            const reslicedBytes = reslice(charIndices, bits, 8, false);\n            bytes.set(reslicedBytes, offset);\n            return reslicedBytes.length + offset;\n        },\n    });\n\n/**\n * Returns a decoder for base-X encoded strings using bit re-slicing.\n *\n * This decoder deserializes base-X encoded strings by re-slicing the bits of a byte array into\n * custom-sized chunks and mapping them to a specified alphabet.\n * This is typically used for encoding schemes where the alphabet's length is a power of 2,\n * such as base-16 or base-64.\n *\n * For more details, see {@link getBaseXResliceCodec}.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @param bits - The number of bits per encoded chunk, typically `log2(alphabet.length)`.\n * @returns A `VariableSizeDecoder<string>` for decoding base-X strings using bit re-slicing.\n *\n * @example\n * Decoding a base-X string using bit re-slicing.\n * ```ts\n * const decoder = getBaseXResliceDecoder('elho', 2);\n * const value = decoder.decode(new Uint8Array([0x4a, 0xee])); // \"hellolol\"\n * ```\n *\n * @see {@link getBaseXResliceCodec}\n */\nexport const getBaseXResliceDecoder = (alphabet: string, bits: number): VariableSizeDecoder<string> =>\n    createDecoder({\n        read(rawBytes, offset = 0): [string, number] {\n            const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);\n            if (bytes.length === 0) return ['', rawBytes.length];\n            const charIndices = reslice([...bytes], 8, bits, true);\n            return [charIndices.map(i => alphabet[i]).join(''), rawBytes.length];\n        },\n    });\n\n/**\n * Returns a codec for encoding and decoding base-X strings using bit re-slicing.\n *\n * This codec serializes strings by dividing the input into custom-sized bit chunks,\n * mapping them to a given alphabet, and encoding the result into bytes.\n * It is particularly suited for encoding schemes where the alphabet's length is a power of 2,\n * such as base-16 or base-64.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @param bits - The number of bits per encoded chunk, typically `log2(alphabet.length)`.\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-X strings using bit re-slicing.\n *\n * @example\n * Encoding and decoding a base-X string using bit re-slicing.\n * ```ts\n * const codec = getBaseXResliceCodec('elho', 2);\n * const bytes = codec.encode('hellolol'); // 0x4aee\n * const value = codec.decode(bytes);      // \"hellolol\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-X codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBaseXResliceCodec('elho', 2), 8);\n * ```\n *\n * If you need a size-prefixed base-X codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBaseXResliceCodec('elho', 2), getU32Codec());\n * ```\n *\n * Separate {@link getBaseXResliceEncoder} and {@link getBaseXResliceDecoder} functions are available.\n *\n * ```ts\n * const bytes = getBaseXResliceEncoder('elho', 2).encode('hellolol');\n * const value = getBaseXResliceDecoder('elho', 2).decode(bytes);\n * ```\n *\n * @see {@link getBaseXResliceEncoder}\n * @see {@link getBaseXResliceDecoder}\n */\nexport const getBaseXResliceCodec = (alphabet: string, bits: number): VariableSizeCodec<string> =>\n    combineCodec(getBaseXResliceEncoder(alphabet, bits), getBaseXResliceDecoder(alphabet, bits));\n\n/** Helper function to reslice the bits inside bytes. */\nfunction reslice(input: number[], inputBits: number, outputBits: number, useRemainder: boolean): number[] {\n    const output = [];\n    let accumulator = 0;\n    let bitsInAccumulator = 0;\n    const mask = (1 << outputBits) - 1;\n    for (const value of input) {\n        accumulator = (accumulator << inputBits) | value;\n        bitsInAccumulator += inputBits;\n        while (bitsInAccumulator >= outputBits) {\n            bitsInAccumulator -= outputBits;\n            output.push((accumulator >> bitsInAccumulator) & mask);\n        }\n    }\n    if (useRemainder && bitsInAccumulator > 0) {\n        output.push((accumulator << (outputBits - bitsInAccumulator)) & mask);\n    }\n    return output;\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\nimport { assertValidBaseString } from './assertions';\nimport { getBaseXResliceDecoder, getBaseXResliceEncoder } from './baseX-reslice';\n\nconst alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n/**\n * Returns an encoder for base-64 strings.\n *\n * This encoder serializes strings using a base-64 encoding scheme,\n * commonly used for data encoding in URLs, cryptographic keys, and binary-to-text encoding.\n *\n * For more details, see {@link getBase64Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding base-64 strings.\n *\n * @example\n * Encoding a base-64 string.\n * ```ts\n * const encoder = getBase64Encoder();\n * const bytes = encoder.encode('hello+world'); // 0x85e965a3ec28ae57\n * ```\n *\n * @see {@link getBase64Codec}\n */\nexport const getBase64Encoder = (): VariableSizeEncoder<string> => {\n    if (__BROWSER__) {\n        return createEncoder({\n            getSizeFromValue: (value: string) => {\n                try {\n                    return (atob as Window['atob'])(value).length;\n                } catch {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        alphabet,\n                        base: 64,\n                        value,\n                    });\n                }\n            },\n            write(value: string, bytes, offset) {\n                try {\n                    const bytesToAdd = (atob as Window['atob'])(value)\n                        .split('')\n                        .map(c => c.charCodeAt(0));\n                    bytes.set(bytesToAdd, offset);\n                    return bytesToAdd.length + offset;\n                } catch {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        alphabet,\n                        base: 64,\n                        value,\n                    });\n                }\n            },\n        });\n    }\n\n    if (__NODEJS__) {\n        return createEncoder({\n            getSizeFromValue: (value: string) => Buffer.from(value, 'base64').length,\n            write(value: string, bytes, offset) {\n                assertValidBaseString(alphabet, value.replace(/=/g, ''));\n                const buffer = Buffer.from(value, 'base64');\n                bytes.set(buffer, offset);\n                return buffer.length + offset;\n            },\n        });\n    }\n\n    return transformEncoder(getBaseXResliceEncoder(alphabet, 6), (value: string): string => value.replace(/=/g, ''));\n};\n\n/**\n * Returns a decoder for base-64 strings.\n *\n * This decoder deserializes base-64 encoded strings from a byte array.\n *\n * For more details, see {@link getBase64Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding base-64 strings.\n *\n * @example\n * Decoding a base-64 string.\n * ```ts\n * const decoder = getBase64Decoder();\n * const value = decoder.decode(new Uint8Array([0x85, 0xe9, 0x65, 0xa3, 0xec, 0x28, 0xae, 0x57])); // \"hello+world\"\n * ```\n *\n * @see {@link getBase64Codec}\n */\nexport const getBase64Decoder = (): VariableSizeDecoder<string> => {\n    if (__BROWSER__) {\n        return createDecoder({\n            read(bytes, offset = 0) {\n                const slice = bytes.slice(offset);\n                const value = (btoa as Window['btoa'])(String.fromCharCode(...slice));\n                return [value, bytes.length];\n            },\n        });\n    }\n\n    if (__NODEJS__) {\n        return createDecoder({\n            read: (bytes, offset = 0) => [Buffer.from(bytes, offset).toString('base64'), bytes.length],\n        });\n    }\n\n    return transformDecoder(getBaseXResliceDecoder(alphabet, 6), (value: string): string =>\n        value.padEnd(Math.ceil(value.length / 4) * 4, '='),\n    );\n};\n\n/**\n * Returns a codec for encoding and decoding base-64 strings.\n *\n * This codec serializes strings using a base-64 encoding scheme,\n * commonly used for data encoding in URLs, cryptographic keys, and binary-to-text encoding.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-64 strings.\n *\n * @example\n * Encoding and decoding a base-64 string.\n * ```ts\n * const codec = getBase64Codec();\n * const bytes = codec.encode('hello+world'); // 0x85e965a3ec28ae57\n * const value = codec.decode(bytes);         // \"hello+world\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-64 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBase64Codec(), 8);\n * ```\n *\n * If you need a size-prefixed base-64 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBase64Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getBase64Encoder} and {@link getBase64Decoder} functions are available.\n *\n * ```ts\n * const bytes = getBase64Encoder().encode('hello+world');\n * const value = getBase64Decoder().decode(bytes);\n * ```\n *\n * @see {@link getBase64Encoder}\n * @see {@link getBase64Decoder}\n */\nexport const getBase64Codec = (): VariableSizeCodec<string> => combineCodec(getBase64Encoder(), getBase64Decoder());\n","/**\n * Removes all null characters (`\\u0000`) from a string.\n *\n * This function cleans a string by stripping out any null characters,\n * which are often used as padding in fixed-size string encodings.\n *\n * @param value - The string to process.\n * @returns The input string with all null characters removed.\n *\n * @example\n * Removing null characters from a string.\n * ```ts\n * removeNullCharacters('hello\\u0000\\u0000'); // \"hello\"\n * ```\n */\nexport const removeNullCharacters = (value: string) =>\n    // eslint-disable-next-line no-control-regex\n    value.replace(/\\u0000/g, '');\n\n/**\n * Pads a string with null characters (`\\u0000`) at the end to reach a fixed length.\n *\n * If the input string is shorter than the specified length, it is padded with null characters\n * until it reaches the desired size. If it is already long enough, it remains unchanged.\n *\n * @param value - The string to pad.\n * @param chars - The total length of the resulting string, including padding.\n * @returns The input string padded with null characters up to the specified length.\n *\n * @example\n * Padding a string with null characters.\n * ```ts\n * padNullCharacters('hello', 8); // \"hello\\u0000\\u0000\\u0000\"\n * ```\n */\nexport const padNullCharacters = (value: string, chars: number) => value.padEnd(chars, '\\u0000');\n","export const TextDecoder = globalThis.TextDecoder;\nexport const TextEncoder = globalThis.TextEncoder;\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { TextDecoder, TextEncoder } from '@solana/text-encoding-impl';\n\nimport { removeNullCharacters } from './null-characters';\n\n/**\n * Returns an encoder for UTF-8 strings.\n *\n * This encoder serializes strings using UTF-8 encoding.\n * The encoded output contains as many bytes as needed to represent the string.\n *\n * For more details, see {@link getUtf8Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding UTF-8 strings.\n *\n * @example\n * Encoding a UTF-8 string.\n * ```ts\n * const encoder = getUtf8Encoder();\n * const bytes = encoder.encode('hello'); // 0x68656c6c6f\n * ```\n *\n * @see {@link getUtf8Codec}\n */\nexport const getUtf8Encoder = (): VariableSizeEncoder<string> => {\n    let textEncoder: TextEncoder;\n    return createEncoder({\n        getSizeFromValue: value => (textEncoder ||= new TextEncoder()).encode(value).length,\n        write: (value: string, bytes, offset) => {\n            const bytesToAdd = (textEncoder ||= new TextEncoder()).encode(value);\n            bytes.set(bytesToAdd, offset);\n            return offset + bytesToAdd.length;\n        },\n    });\n};\n\n/**\n * Returns a decoder for UTF-8 strings.\n *\n * This decoder deserializes UTF-8 encoded strings from a byte array.\n * It reads all available bytes starting from the given offset.\n *\n * For more details, see {@link getUtf8Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding UTF-8 strings.\n *\n * @example\n * Decoding a UTF-8 string.\n * ```ts\n * const decoder = getUtf8Decoder();\n * const value = decoder.decode(new Uint8Array([0x68, 0x65, 0x6c, 0x6c, 0x6f])); // \"hello\"\n * ```\n *\n * @see {@link getUtf8Codec}\n */\nexport const getUtf8Decoder = (): VariableSizeDecoder<string> => {\n    let textDecoder: TextDecoder;\n    return createDecoder({\n        read(bytes, offset) {\n            const value = (textDecoder ||= new TextDecoder()).decode(bytes.slice(offset));\n            return [removeNullCharacters(value), bytes.length];\n        },\n    });\n};\n\n/**\n * Returns a codec for encoding and decoding UTF-8 strings.\n *\n * This codec serializes strings using UTF-8 encoding.\n * The encoded output contains as many bytes as needed to represent the string.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding UTF-8 strings.\n *\n * @example\n * Encoding and decoding a UTF-8 string.\n * ```ts\n * const codec = getUtf8Codec();\n * const bytes = codec.encode('hello'); // 0x68656c6c6f\n * const value = codec.decode(bytes);   // \"hello\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size UTF-8 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getUtf8Codec(), 5);\n * ```\n *\n * If you need a size-prefixed UTF-8 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getUtf8Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getUtf8Encoder} and {@link getUtf8Decoder} functions are available.\n *\n * ```ts\n * const bytes = getUtf8Encoder().encode('hello');\n * const value = getUtf8Decoder().decode(bytes);\n * ```\n *\n * @see {@link getUtf8Encoder}\n * @see {@link getUtf8Decoder}\n */\nexport const getUtf8Codec = (): VariableSizeCodec<string> => combineCodec(getUtf8Encoder(), getUtf8Decoder());\n"],"names":["alphabet","createEncoder","SolanaError","SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE","createDecoder","combineCodec","TextDecoder","TextEncoder"],"mappings":"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","debugId":null}},
    {"offset": {"line": 1396, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/accounts/node_modules/@solana/codecs-strings/dist/index.browser.mjs","sources":["file:///Users/ivaylobakalov/web3/solana/voting-dapp/frontend/node_modules/%40solana/accounts/node_modules/%40solana/codecs-strings/src/assertions.ts","file:///Users/ivaylobakalov/web3/solana/voting-dapp/frontend/node_modules/%40solana/accounts/node_modules/%40solana/codecs-strings/src/baseX.ts","file:///Users/ivaylobakalov/web3/solana/voting-dapp/frontend/node_modules/%40solana/accounts/node_modules/%40solana/codecs-strings/src/base10.ts","file:///Users/ivaylobakalov/web3/solana/voting-dapp/frontend/node_modules/%40solana/accounts/node_modules/%40solana/codecs-strings/src/base16.ts","file:///Users/ivaylobakalov/web3/solana/voting-dapp/frontend/node_modules/%40solana/accounts/node_modules/%40solana/codecs-strings/src/base58.ts","file:///Users/ivaylobakalov/web3/solana/voting-dapp/frontend/node_modules/%40solana/accounts/node_modules/%40solana/codecs-strings/src/baseX-reslice.ts","file:///Users/ivaylobakalov/web3/solana/voting-dapp/frontend/node_modules/%40solana/accounts/node_modules/%40solana/codecs-strings/src/base64.ts","file:///Users/ivaylobakalov/web3/solana/voting-dapp/frontend/node_modules/%40solana/accounts/node_modules/%40solana/codecs-strings/src/null-characters.ts","file:///Users/ivaylobakalov/web3/solana/voting-dapp/frontend/node_modules/%40solana/accounts/node_modules/%40solana/text-encoding-impl/src/index.browser.ts","file:///Users/ivaylobakalov/web3/solana/voting-dapp/frontend/node_modules/%40solana/accounts/node_modules/%40solana/codecs-strings/src/utf8.ts"],"sourcesContent":["import { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\n/**\n * Asserts that a given string contains only characters from the specified alphabet.\n *\n * This function validates whether a string consists exclusively of characters\n * from the provided `alphabet`. If the validation fails, it throws an error\n * indicating the invalid base string.\n *\n * @param alphabet - The allowed set of characters for the base encoding.\n * @param testValue - The string to validate against the given alphabet.\n * @param givenValue - The original string provided by the user (defaults to `testValue`).\n *\n * @throws {SolanaError} If `testValue` contains characters not present in `alphabet`.\n *\n * @example\n * Validating a base-8 encoded string.\n * ```ts\n * assertValidBaseString('01234567', '123047'); // Passes\n * assertValidBaseString('01234567', '128');    // Throws error\n * ```\n */\nexport function assertValidBaseString(alphabet: string, testValue: string, givenValue = testValue) {\n    if (!testValue.match(new RegExp(`^[${alphabet}]*$`))) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n            alphabet,\n            base: alphabet.length,\n            value: givenValue,\n        });\n    }\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertValidBaseString } from './assertions';\n\n/**\n * Returns an encoder for base-X encoded strings.\n *\n * This encoder serializes strings using a custom alphabet, treating the length of the alphabet as the base.\n * The encoding process involves converting the input string to a numeric value in base-X, then\n * encoding that value into bytes while preserving leading zeroes.\n *\n * For more details, see {@link getBaseXCodec}.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @returns A `VariableSizeEncoder<string>` for encoding base-X strings.\n *\n * @example\n * Encoding a base-X string using a custom alphabet.\n * ```ts\n * const encoder = getBaseXEncoder('0123456789abcdef');\n * const bytes = encoder.encode('deadface'); // 0xdeadface\n * ```\n *\n * @see {@link getBaseXCodec}\n */\nexport const getBaseXEncoder = (alphabet: string): VariableSizeEncoder<string> => {\n    return createEncoder({\n        getSizeFromValue: (value: string): number => {\n            const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet[0]);\n            if (!tailChars) return value.length;\n\n            const base10Number = getBigIntFromBaseX(tailChars, alphabet);\n            return leadingZeroes.length + Math.ceil(base10Number.toString(16).length / 2);\n        },\n        write(value: string, bytes, offset) {\n            // Check if the value is valid.\n            assertValidBaseString(alphabet, value);\n            if (value === '') return offset;\n\n            // Handle leading zeroes.\n            const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet[0]);\n            if (!tailChars) {\n                bytes.set(new Uint8Array(leadingZeroes.length).fill(0), offset);\n                return offset + leadingZeroes.length;\n            }\n\n            // From baseX to base10.\n            let base10Number = getBigIntFromBaseX(tailChars, alphabet);\n\n            // From base10 to bytes.\n            const tailBytes: number[] = [];\n            while (base10Number > 0n) {\n                tailBytes.unshift(Number(base10Number % 256n));\n                base10Number /= 256n;\n            }\n\n            const bytesToAdd = [...Array(leadingZeroes.length).fill(0), ...tailBytes];\n            bytes.set(bytesToAdd, offset);\n            return offset + bytesToAdd.length;\n        },\n    });\n};\n\n/**\n * Returns a decoder for base-X encoded strings.\n *\n * This decoder deserializes base-X encoded strings from a byte array using a custom alphabet.\n * The decoding process converts the byte array into a numeric value in base-10, then\n * maps that value back to characters in the specified base-X alphabet.\n *\n * For more details, see {@link getBaseXCodec}.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @returns A `VariableSizeDecoder<string>` for decoding base-X strings.\n *\n * @example\n * Decoding a base-X string using a custom alphabet.\n * ```ts\n * const decoder = getBaseXDecoder('0123456789abcdef');\n * const value = decoder.decode(new Uint8Array([0xde, 0xad, 0xfa, 0xce])); // \"deadface\"\n * ```\n *\n * @see {@link getBaseXCodec}\n */\nexport const getBaseXDecoder = (alphabet: string): VariableSizeDecoder<string> => {\n    return createDecoder({\n        read(rawBytes, offset): [string, number] {\n            const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);\n            if (bytes.length === 0) return ['', 0];\n\n            // Handle leading zeroes.\n            let trailIndex = bytes.findIndex(n => n !== 0);\n            trailIndex = trailIndex === -1 ? bytes.length : trailIndex;\n            const leadingZeroes = alphabet[0].repeat(trailIndex);\n            if (trailIndex === bytes.length) return [leadingZeroes, rawBytes.length];\n\n            // From bytes to base10.\n            const base10Number = bytes.slice(trailIndex).reduce((sum, byte) => sum * 256n + BigInt(byte), 0n);\n\n            // From base10 to baseX.\n            const tailChars = getBaseXFromBigInt(base10Number, alphabet);\n\n            return [leadingZeroes + tailChars, rawBytes.length];\n        },\n    });\n};\n\n/**\n * Returns a codec for encoding and decoding base-X strings.\n *\n * This codec serializes strings using a custom alphabet, treating the length of the alphabet as the base.\n * The encoding process converts the input string into a numeric value in base-X, which is then encoded as bytes.\n * The decoding process reverses this transformation to reconstruct the original string.\n *\n * This codec supports leading zeroes by treating the first character of the alphabet as the zero character.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-X strings.\n *\n * @example\n * Encoding and decoding a base-X string using a custom alphabet.\n * ```ts\n * const codec = getBaseXCodec('0123456789abcdef');\n * const bytes = codec.encode('deadface'); // 0xdeadface\n * const value = codec.decode(bytes);      // \"deadface\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-X codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBaseXCodec('0123456789abcdef'), 8);\n * ```\n *\n * If you need a size-prefixed base-X codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBaseXCodec('0123456789abcdef'), getU32Codec());\n * ```\n *\n * Separate {@link getBaseXEncoder} and {@link getBaseXDecoder} functions are available.\n *\n * ```ts\n * const bytes = getBaseXEncoder('0123456789abcdef').encode('deadface');\n * const value = getBaseXDecoder('0123456789abcdef').decode(bytes);\n * ```\n *\n * @see {@link getBaseXEncoder}\n * @see {@link getBaseXDecoder}\n */\nexport const getBaseXCodec = (alphabet: string): VariableSizeCodec<string> =>\n    combineCodec(getBaseXEncoder(alphabet), getBaseXDecoder(alphabet));\n\nfunction partitionLeadingZeroes(\n    value: string,\n    zeroCharacter: string,\n): [leadingZeros: string, tailChars: string | undefined] {\n    const [leadingZeros, tailChars] = value.split(new RegExp(`((?!${zeroCharacter}).*)`));\n    return [leadingZeros, tailChars];\n}\n\nfunction getBigIntFromBaseX(value: string, alphabet: string): bigint {\n    const base = BigInt(alphabet.length);\n    let sum = 0n;\n    for (const char of value) {\n        sum *= base;\n        sum += BigInt(alphabet.indexOf(char));\n    }\n    return sum;\n}\n\nfunction getBaseXFromBigInt(value: bigint, alphabet: string): string {\n    const base = BigInt(alphabet.length);\n    const tailChars = [];\n    while (value > 0n) {\n        tailChars.unshift(alphabet[Number(value % base)]);\n        value /= base;\n    }\n    return tailChars.join('');\n}\n","import { getBaseXCodec, getBaseXDecoder, getBaseXEncoder } from './baseX';\n\nconst alphabet = '0123456789';\n\n/**\n * Returns an encoder for base-10 strings.\n *\n * This encoder serializes strings using a base-10 encoding scheme.\n * The output consists of bytes representing the numerical values of the input string.\n *\n * For more details, see {@link getBase10Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding base-10 strings.\n *\n * @example\n * Encoding a base-10 string.\n * ```ts\n * const encoder = getBase10Encoder();\n * const bytes = encoder.encode('1024'); // 0x0400\n * ```\n *\n * @see {@link getBase10Codec}\n */\nexport const getBase10Encoder = () => getBaseXEncoder(alphabet);\n\n/**\n * Returns a decoder for base-10 strings.\n *\n * This decoder deserializes base-10 encoded strings from a byte array.\n *\n * For more details, see {@link getBase10Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding base-10 strings.\n *\n * @example\n * Decoding a base-10 string.\n * ```ts\n * const decoder = getBase10Decoder();\n * const value = decoder.decode(new Uint8Array([0x04, 0x00])); // \"1024\"\n * ```\n *\n * @see {@link getBase10Codec}\n */\nexport const getBase10Decoder = () => getBaseXDecoder(alphabet);\n\n/**\n * Returns a codec for encoding and decoding base-10 strings.\n *\n * This codec serializes strings using a base-10 encoding scheme.\n * The output consists of bytes representing the numerical values of the input string.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-10 strings.\n *\n * @example\n * Encoding and decoding a base-10 string.\n * ```ts\n * const codec = getBase10Codec();\n * const bytes = codec.encode('1024'); // 0x0400\n * const value = codec.decode(bytes);  // \"1024\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-10 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBase10Codec(), 5);\n * ```\n *\n * If you need a size-prefixed base-10 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBase10Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getBase10Encoder} and {@link getBase10Decoder} functions are available.\n *\n * ```ts\n * const bytes = getBase10Encoder().encode('1024');\n * const value = getBase10Decoder().decode(bytes);\n * ```\n *\n * @see {@link getBase10Encoder}\n * @see {@link getBase10Decoder}\n */\nexport const getBase10Codec = () => getBaseXCodec(alphabet);\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\nconst enum HexC {\n    ZERO = 48, // 0\n    NINE = 57, // 9\n    A_UP = 65, // A\n    F_UP = 70, // F\n    A_LO = 97, // a\n    F_LO = 102, // f\n}\n\nconst INVALID_STRING_ERROR_BASE_CONFIG = {\n    alphabet: '0123456789abcdef',\n    base: 16,\n} as const;\n\nfunction charCodeToBase16(char: number) {\n    if (char >= HexC.ZERO && char <= HexC.NINE) return char - HexC.ZERO;\n    if (char >= HexC.A_UP && char <= HexC.F_UP) return char - (HexC.A_UP - 10);\n    if (char >= HexC.A_LO && char <= HexC.F_LO) return char - (HexC.A_LO - 10);\n}\n\n/**\n * Returns an encoder for base-16 (hexadecimal) strings.\n *\n * This encoder serializes strings using a base-16 encoding scheme.\n * The output consists of bytes representing the hexadecimal values of the input string.\n *\n * For more details, see {@link getBase16Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding base-16 strings.\n *\n * @example\n * Encoding a base-16 string.\n * ```ts\n * const encoder = getBase16Encoder();\n * const bytes = encoder.encode('deadface'); // 0xdeadface\n * ```\n *\n * @see {@link getBase16Codec}\n */\nexport const getBase16Encoder = (): VariableSizeEncoder<string> =>\n    createEncoder({\n        getSizeFromValue: (value: string) => Math.ceil(value.length / 2),\n        write(value: string, bytes, offset) {\n            const len = value.length;\n            const al = len / 2;\n            if (len === 1) {\n                const c = value.charCodeAt(0);\n                const n = charCodeToBase16(c);\n                if (n === undefined) {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        ...INVALID_STRING_ERROR_BASE_CONFIG,\n                        value,\n                    });\n                }\n                bytes.set([n], offset);\n                return 1 + offset;\n            }\n            const hexBytes = new Uint8Array(al);\n            for (let i = 0, j = 0; i < al; i++) {\n                const c1 = value.charCodeAt(j++);\n                const c2 = value.charCodeAt(j++);\n\n                const n1 = charCodeToBase16(c1);\n                const n2 = charCodeToBase16(c2);\n                if (n1 === undefined || (n2 === undefined && !Number.isNaN(c2))) {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        ...INVALID_STRING_ERROR_BASE_CONFIG,\n                        value,\n                    });\n                }\n                hexBytes[i] = !Number.isNaN(c2) ? (n1 << 4) | (n2 ?? 0) : n1;\n            }\n\n            bytes.set(hexBytes, offset);\n            return hexBytes.length + offset;\n        },\n    });\n\n/**\n * Returns a decoder for base-16 (hexadecimal) strings.\n *\n * This decoder deserializes base-16 encoded strings from a byte array.\n *\n * For more details, see {@link getBase16Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding base-16 strings.\n *\n * @example\n * Decoding a base-16 string.\n * ```ts\n * const decoder = getBase16Decoder();\n * const value = decoder.decode(new Uint8Array([0xde, 0xad, 0xfa, 0xce])); // \"deadface\"\n * ```\n *\n * @see {@link getBase16Codec}\n */\nexport const getBase16Decoder = (): VariableSizeDecoder<string> =>\n    createDecoder({\n        read(bytes, offset) {\n            const value = bytes.slice(offset).reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n            return [value, bytes.length];\n        },\n    });\n\n/**\n * Returns a codec for encoding and decoding base-16 (hexadecimal) strings.\n *\n * This codec serializes strings using a base-16 encoding scheme.\n * The output consists of bytes representing the hexadecimal values of the input string.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-16 strings.\n *\n * @example\n * Encoding and decoding a base-16 string.\n * ```ts\n * const codec = getBase16Codec();\n * const bytes = codec.encode('deadface'); // 0xdeadface\n * const value = codec.decode(bytes);      // \"deadface\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-16 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBase16Codec(), 8);\n * ```\n *\n * If you need a size-prefixed base-16 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBase16Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getBase16Encoder} and {@link getBase16Decoder} functions are available.\n *\n * ```ts\n * const bytes = getBase16Encoder().encode('deadface');\n * const value = getBase16Decoder().decode(bytes);\n * ```\n *\n * @see {@link getBase16Encoder}\n * @see {@link getBase16Decoder}\n */\nexport const getBase16Codec = (): VariableSizeCodec<string> => combineCodec(getBase16Encoder(), getBase16Decoder());\n","import { getBaseXCodec, getBaseXDecoder, getBaseXEncoder } from './baseX';\n\nconst alphabet = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\n\n/**\n * Returns an encoder for base-58 strings.\n *\n * This encoder serializes strings using a base-58 encoding scheme,\n * commonly used in cryptocurrency addresses and other compact representations.\n *\n * For more details, see {@link getBase58Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding base-58 strings.\n *\n * @example\n * Encoding a base-58 string.\n * ```ts\n * const encoder = getBase58Encoder();\n * const bytes = encoder.encode('heLLo'); // 0x1b6a3070\n * ```\n *\n * @see {@link getBase58Codec}\n */\nexport const getBase58Encoder = () => getBaseXEncoder(alphabet);\n\n/**\n * Returns a decoder for base-58 strings.\n *\n * This decoder deserializes base-58 encoded strings from a byte array.\n *\n * For more details, see {@link getBase58Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding base-58 strings.\n *\n * @example\n * Decoding a base-58 string.\n * ```ts\n * const decoder = getBase58Decoder();\n * const value = decoder.decode(new Uint8Array([0x1b, 0x6a, 0x30, 0x70])); // \"heLLo\"\n * ```\n *\n * @see {@link getBase58Codec}\n */\nexport const getBase58Decoder = () => getBaseXDecoder(alphabet);\n\n/**\n * Returns a codec for encoding and decoding base-58 strings.\n *\n * This codec serializes strings using a base-58 encoding scheme,\n * commonly used in cryptocurrency addresses and other compact representations.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-58 strings.\n *\n * @example\n * Encoding and decoding a base-58 string.\n * ```ts\n * const codec = getBase58Codec();\n * const bytes = codec.encode('heLLo'); // 0x1b6a3070\n * const value = codec.decode(bytes);   // \"heLLo\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-58 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBase58Codec(), 8);\n * ```\n *\n * If you need a size-prefixed base-58 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBase58Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getBase58Encoder} and {@link getBase58Decoder} functions are available.\n *\n * ```ts\n * const bytes = getBase58Encoder().encode('heLLo');\n * const value = getBase58Decoder().decode(bytes);\n * ```\n *\n * @see {@link getBase58Encoder}\n * @see {@link getBase58Decoder}\n */\nexport const getBase58Codec = () => getBaseXCodec(alphabet);\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertValidBaseString } from './assertions';\n\n/**\n * Returns an encoder for base-X encoded strings using bit re-slicing.\n *\n * This encoder serializes strings by dividing the input into custom-sized bit chunks,\n * mapping them to an alphabet, and encoding the result into a byte array.\n * This approach is commonly used for encoding schemes where the alphabet's length is a power of 2,\n * such as base-16 or base-64.\n *\n * For more details, see {@link getBaseXResliceCodec}.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @param bits - The number of bits per encoded chunk, typically `log2(alphabet.length)`.\n * @returns A `VariableSizeEncoder<string>` for encoding base-X strings using bit re-slicing.\n *\n * @example\n * Encoding a base-X string using bit re-slicing.\n * ```ts\n * const encoder = getBaseXResliceEncoder('elho', 2);\n * const bytes = encoder.encode('hellolol'); // 0x4aee\n * ```\n *\n * @see {@link getBaseXResliceCodec}\n */\nexport const getBaseXResliceEncoder = (alphabet: string, bits: number): VariableSizeEncoder<string> =>\n    createEncoder({\n        getSizeFromValue: (value: string) => Math.floor((value.length * bits) / 8),\n        write(value: string, bytes, offset) {\n            assertValidBaseString(alphabet, value);\n            if (value === '') return offset;\n            const charIndices = [...value].map(c => alphabet.indexOf(c));\n            const reslicedBytes = reslice(charIndices, bits, 8, false);\n            bytes.set(reslicedBytes, offset);\n            return reslicedBytes.length + offset;\n        },\n    });\n\n/**\n * Returns a decoder for base-X encoded strings using bit re-slicing.\n *\n * This decoder deserializes base-X encoded strings by re-slicing the bits of a byte array into\n * custom-sized chunks and mapping them to a specified alphabet.\n * This is typically used for encoding schemes where the alphabet's length is a power of 2,\n * such as base-16 or base-64.\n *\n * For more details, see {@link getBaseXResliceCodec}.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @param bits - The number of bits per encoded chunk, typically `log2(alphabet.length)`.\n * @returns A `VariableSizeDecoder<string>` for decoding base-X strings using bit re-slicing.\n *\n * @example\n * Decoding a base-X string using bit re-slicing.\n * ```ts\n * const decoder = getBaseXResliceDecoder('elho', 2);\n * const value = decoder.decode(new Uint8Array([0x4a, 0xee])); // \"hellolol\"\n * ```\n *\n * @see {@link getBaseXResliceCodec}\n */\nexport const getBaseXResliceDecoder = (alphabet: string, bits: number): VariableSizeDecoder<string> =>\n    createDecoder({\n        read(rawBytes, offset = 0): [string, number] {\n            const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);\n            if (bytes.length === 0) return ['', rawBytes.length];\n            const charIndices = reslice([...bytes], 8, bits, true);\n            return [charIndices.map(i => alphabet[i]).join(''), rawBytes.length];\n        },\n    });\n\n/**\n * Returns a codec for encoding and decoding base-X strings using bit re-slicing.\n *\n * This codec serializes strings by dividing the input into custom-sized bit chunks,\n * mapping them to a given alphabet, and encoding the result into bytes.\n * It is particularly suited for encoding schemes where the alphabet's length is a power of 2,\n * such as base-16 or base-64.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @param bits - The number of bits per encoded chunk, typically `log2(alphabet.length)`.\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-X strings using bit re-slicing.\n *\n * @example\n * Encoding and decoding a base-X string using bit re-slicing.\n * ```ts\n * const codec = getBaseXResliceCodec('elho', 2);\n * const bytes = codec.encode('hellolol'); // 0x4aee\n * const value = codec.decode(bytes);      // \"hellolol\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-X codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBaseXResliceCodec('elho', 2), 8);\n * ```\n *\n * If you need a size-prefixed base-X codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBaseXResliceCodec('elho', 2), getU32Codec());\n * ```\n *\n * Separate {@link getBaseXResliceEncoder} and {@link getBaseXResliceDecoder} functions are available.\n *\n * ```ts\n * const bytes = getBaseXResliceEncoder('elho', 2).encode('hellolol');\n * const value = getBaseXResliceDecoder('elho', 2).decode(bytes);\n * ```\n *\n * @see {@link getBaseXResliceEncoder}\n * @see {@link getBaseXResliceDecoder}\n */\nexport const getBaseXResliceCodec = (alphabet: string, bits: number): VariableSizeCodec<string> =>\n    combineCodec(getBaseXResliceEncoder(alphabet, bits), getBaseXResliceDecoder(alphabet, bits));\n\n/** Helper function to reslice the bits inside bytes. */\nfunction reslice(input: number[], inputBits: number, outputBits: number, useRemainder: boolean): number[] {\n    const output = [];\n    let accumulator = 0;\n    let bitsInAccumulator = 0;\n    const mask = (1 << outputBits) - 1;\n    for (const value of input) {\n        accumulator = (accumulator << inputBits) | value;\n        bitsInAccumulator += inputBits;\n        while (bitsInAccumulator >= outputBits) {\n            bitsInAccumulator -= outputBits;\n            output.push((accumulator >> bitsInAccumulator) & mask);\n        }\n    }\n    if (useRemainder && bitsInAccumulator > 0) {\n        output.push((accumulator << (outputBits - bitsInAccumulator)) & mask);\n    }\n    return output;\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\nimport { assertValidBaseString } from './assertions';\nimport { getBaseXResliceDecoder, getBaseXResliceEncoder } from './baseX-reslice';\n\nconst alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n/**\n * Returns an encoder for base-64 strings.\n *\n * This encoder serializes strings using a base-64 encoding scheme,\n * commonly used for data encoding in URLs, cryptographic keys, and binary-to-text encoding.\n *\n * For more details, see {@link getBase64Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding base-64 strings.\n *\n * @example\n * Encoding a base-64 string.\n * ```ts\n * const encoder = getBase64Encoder();\n * const bytes = encoder.encode('hello+world'); // 0x85e965a3ec28ae57\n * ```\n *\n * @see {@link getBase64Codec}\n */\nexport const getBase64Encoder = (): VariableSizeEncoder<string> => {\n    if (__BROWSER__) {\n        return createEncoder({\n            getSizeFromValue: (value: string) => {\n                try {\n                    return (atob as Window['atob'])(value).length;\n                } catch {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        alphabet,\n                        base: 64,\n                        value,\n                    });\n                }\n            },\n            write(value: string, bytes, offset) {\n                try {\n                    const bytesToAdd = (atob as Window['atob'])(value)\n                        .split('')\n                        .map(c => c.charCodeAt(0));\n                    bytes.set(bytesToAdd, offset);\n                    return bytesToAdd.length + offset;\n                } catch {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        alphabet,\n                        base: 64,\n                        value,\n                    });\n                }\n            },\n        });\n    }\n\n    if (__NODEJS__) {\n        return createEncoder({\n            getSizeFromValue: (value: string) => Buffer.from(value, 'base64').length,\n            write(value: string, bytes, offset) {\n                assertValidBaseString(alphabet, value.replace(/=/g, ''));\n                const buffer = Buffer.from(value, 'base64');\n                bytes.set(buffer, offset);\n                return buffer.length + offset;\n            },\n        });\n    }\n\n    return transformEncoder(getBaseXResliceEncoder(alphabet, 6), (value: string): string => value.replace(/=/g, ''));\n};\n\n/**\n * Returns a decoder for base-64 strings.\n *\n * This decoder deserializes base-64 encoded strings from a byte array.\n *\n * For more details, see {@link getBase64Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding base-64 strings.\n *\n * @example\n * Decoding a base-64 string.\n * ```ts\n * const decoder = getBase64Decoder();\n * const value = decoder.decode(new Uint8Array([0x85, 0xe9, 0x65, 0xa3, 0xec, 0x28, 0xae, 0x57])); // \"hello+world\"\n * ```\n *\n * @see {@link getBase64Codec}\n */\nexport const getBase64Decoder = (): VariableSizeDecoder<string> => {\n    if (__BROWSER__) {\n        return createDecoder({\n            read(bytes, offset = 0) {\n                const slice = bytes.slice(offset);\n                const value = (btoa as Window['btoa'])(String.fromCharCode(...slice));\n                return [value, bytes.length];\n            },\n        });\n    }\n\n    if (__NODEJS__) {\n        return createDecoder({\n            read: (bytes, offset = 0) => [Buffer.from(bytes, offset).toString('base64'), bytes.length],\n        });\n    }\n\n    return transformDecoder(getBaseXResliceDecoder(alphabet, 6), (value: string): string =>\n        value.padEnd(Math.ceil(value.length / 4) * 4, '='),\n    );\n};\n\n/**\n * Returns a codec for encoding and decoding base-64 strings.\n *\n * This codec serializes strings using a base-64 encoding scheme,\n * commonly used for data encoding in URLs, cryptographic keys, and binary-to-text encoding.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-64 strings.\n *\n * @example\n * Encoding and decoding a base-64 string.\n * ```ts\n * const codec = getBase64Codec();\n * const bytes = codec.encode('hello+world'); // 0x85e965a3ec28ae57\n * const value = codec.decode(bytes);         // \"hello+world\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-64 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBase64Codec(), 8);\n * ```\n *\n * If you need a size-prefixed base-64 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBase64Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getBase64Encoder} and {@link getBase64Decoder} functions are available.\n *\n * ```ts\n * const bytes = getBase64Encoder().encode('hello+world');\n * const value = getBase64Decoder().decode(bytes);\n * ```\n *\n * @see {@link getBase64Encoder}\n * @see {@link getBase64Decoder}\n */\nexport const getBase64Codec = (): VariableSizeCodec<string> => combineCodec(getBase64Encoder(), getBase64Decoder());\n","/**\n * Removes all null characters (`\\u0000`) from a string.\n *\n * This function cleans a string by stripping out any null characters,\n * which are often used as padding in fixed-size string encodings.\n *\n * @param value - The string to process.\n * @returns The input string with all null characters removed.\n *\n * @example\n * Removing null characters from a string.\n * ```ts\n * removeNullCharacters('hello\\u0000\\u0000'); // \"hello\"\n * ```\n */\nexport const removeNullCharacters = (value: string) =>\n    // eslint-disable-next-line no-control-regex\n    value.replace(/\\u0000/g, '');\n\n/**\n * Pads a string with null characters (`\\u0000`) at the end to reach a fixed length.\n *\n * If the input string is shorter than the specified length, it is padded with null characters\n * until it reaches the desired size. If it is already long enough, it remains unchanged.\n *\n * @param value - The string to pad.\n * @param chars - The total length of the resulting string, including padding.\n * @returns The input string padded with null characters up to the specified length.\n *\n * @example\n * Padding a string with null characters.\n * ```ts\n * padNullCharacters('hello', 8); // \"hello\\u0000\\u0000\\u0000\"\n * ```\n */\nexport const padNullCharacters = (value: string, chars: number) => value.padEnd(chars, '\\u0000');\n","export const TextDecoder = globalThis.TextDecoder;\nexport const TextEncoder = globalThis.TextEncoder;\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { TextDecoder, TextEncoder } from '@solana/text-encoding-impl';\n\nimport { removeNullCharacters } from './null-characters';\n\n/**\n * Returns an encoder for UTF-8 strings.\n *\n * This encoder serializes strings using UTF-8 encoding.\n * The encoded output contains as many bytes as needed to represent the string.\n *\n * For more details, see {@link getUtf8Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding UTF-8 strings.\n *\n * @example\n * Encoding a UTF-8 string.\n * ```ts\n * const encoder = getUtf8Encoder();\n * const bytes = encoder.encode('hello'); // 0x68656c6c6f\n * ```\n *\n * @see {@link getUtf8Codec}\n */\nexport const getUtf8Encoder = (): VariableSizeEncoder<string> => {\n    let textEncoder: TextEncoder;\n    return createEncoder({\n        getSizeFromValue: value => (textEncoder ||= new TextEncoder()).encode(value).length,\n        write: (value: string, bytes, offset) => {\n            const bytesToAdd = (textEncoder ||= new TextEncoder()).encode(value);\n            bytes.set(bytesToAdd, offset);\n            return offset + bytesToAdd.length;\n        },\n    });\n};\n\n/**\n * Returns a decoder for UTF-8 strings.\n *\n * This decoder deserializes UTF-8 encoded strings from a byte array.\n * It reads all available bytes starting from the given offset.\n *\n * For more details, see {@link getUtf8Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding UTF-8 strings.\n *\n * @example\n * Decoding a UTF-8 string.\n * ```ts\n * const decoder = getUtf8Decoder();\n * const value = decoder.decode(new Uint8Array([0x68, 0x65, 0x6c, 0x6c, 0x6f])); // \"hello\"\n * ```\n *\n * @see {@link getUtf8Codec}\n */\nexport const getUtf8Decoder = (): VariableSizeDecoder<string> => {\n    let textDecoder: TextDecoder;\n    return createDecoder({\n        read(bytes, offset) {\n            const value = (textDecoder ||= new TextDecoder()).decode(bytes.slice(offset));\n            return [removeNullCharacters(value), bytes.length];\n        },\n    });\n};\n\n/**\n * Returns a codec for encoding and decoding UTF-8 strings.\n *\n * This codec serializes strings using UTF-8 encoding.\n * The encoded output contains as many bytes as needed to represent the string.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding UTF-8 strings.\n *\n * @example\n * Encoding and decoding a UTF-8 string.\n * ```ts\n * const codec = getUtf8Codec();\n * const bytes = codec.encode('hello'); // 0x68656c6c6f\n * const value = codec.decode(bytes);   // \"hello\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size UTF-8 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getUtf8Codec(), 5);\n * ```\n *\n * If you need a size-prefixed UTF-8 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getUtf8Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getUtf8Encoder} and {@link getUtf8Decoder} functions are available.\n *\n * ```ts\n * const bytes = getUtf8Encoder().encode('hello');\n * const value = getUtf8Decoder().decode(bytes);\n * ```\n *\n * @see {@link getUtf8Encoder}\n * @see {@link getUtf8Decoder}\n */\nexport const getUtf8Codec = (): VariableSizeCodec<string> => combineCodec(getUtf8Encoder(), getUtf8Decoder());\n"],"names":["alphabet","createEncoder","SolanaError","SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE","createDecoder","combineCodec","TextDecoder","TextEncoder"],"mappings":"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","debugId":null}},
    {"offset": {"line": 1744, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/transaction-confirmation/node_modules/@solana/codecs-strings/dist/index.browser.mjs","sources":["file:///Users/ivaylobakalov/web3/solana/voting-dapp/frontend/node_modules/%40solana/transaction-confirmation/node_modules/%40solana/codecs-strings/src/assertions.ts","file:///Users/ivaylobakalov/web3/solana/voting-dapp/frontend/node_modules/%40solana/transaction-confirmation/node_modules/%40solana/codecs-strings/src/baseX.ts","file:///Users/ivaylobakalov/web3/solana/voting-dapp/frontend/node_modules/%40solana/transaction-confirmation/node_modules/%40solana/codecs-strings/src/base10.ts","file:///Users/ivaylobakalov/web3/solana/voting-dapp/frontend/node_modules/%40solana/transaction-confirmation/node_modules/%40solana/codecs-strings/src/base16.ts","file:///Users/ivaylobakalov/web3/solana/voting-dapp/frontend/node_modules/%40solana/transaction-confirmation/node_modules/%40solana/codecs-strings/src/base58.ts","file:///Users/ivaylobakalov/web3/solana/voting-dapp/frontend/node_modules/%40solana/transaction-confirmation/node_modules/%40solana/codecs-strings/src/baseX-reslice.ts","file:///Users/ivaylobakalov/web3/solana/voting-dapp/frontend/node_modules/%40solana/transaction-confirmation/node_modules/%40solana/codecs-strings/src/base64.ts","file:///Users/ivaylobakalov/web3/solana/voting-dapp/frontend/node_modules/%40solana/transaction-confirmation/node_modules/%40solana/codecs-strings/src/null-characters.ts","file:///Users/ivaylobakalov/web3/solana/voting-dapp/frontend/node_modules/%40solana/transaction-confirmation/node_modules/%40solana/text-encoding-impl/src/index.browser.ts","file:///Users/ivaylobakalov/web3/solana/voting-dapp/frontend/node_modules/%40solana/transaction-confirmation/node_modules/%40solana/codecs-strings/src/utf8.ts"],"sourcesContent":["import { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\n/**\n * Asserts that a given string contains only characters from the specified alphabet.\n *\n * This function validates whether a string consists exclusively of characters\n * from the provided `alphabet`. If the validation fails, it throws an error\n * indicating the invalid base string.\n *\n * @param alphabet - The allowed set of characters for the base encoding.\n * @param testValue - The string to validate against the given alphabet.\n * @param givenValue - The original string provided by the user (defaults to `testValue`).\n *\n * @throws {SolanaError} If `testValue` contains characters not present in `alphabet`.\n *\n * @example\n * Validating a base-8 encoded string.\n * ```ts\n * assertValidBaseString('01234567', '123047'); // Passes\n * assertValidBaseString('01234567', '128');    // Throws error\n * ```\n */\nexport function assertValidBaseString(alphabet: string, testValue: string, givenValue = testValue) {\n    if (!testValue.match(new RegExp(`^[${alphabet}]*$`))) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n            alphabet,\n            base: alphabet.length,\n            value: givenValue,\n        });\n    }\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertValidBaseString } from './assertions';\n\n/**\n * Returns an encoder for base-X encoded strings.\n *\n * This encoder serializes strings using a custom alphabet, treating the length of the alphabet as the base.\n * The encoding process involves converting the input string to a numeric value in base-X, then\n * encoding that value into bytes while preserving leading zeroes.\n *\n * For more details, see {@link getBaseXCodec}.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @returns A `VariableSizeEncoder<string>` for encoding base-X strings.\n *\n * @example\n * Encoding a base-X string using a custom alphabet.\n * ```ts\n * const encoder = getBaseXEncoder('0123456789abcdef');\n * const bytes = encoder.encode('deadface'); // 0xdeadface\n * ```\n *\n * @see {@link getBaseXCodec}\n */\nexport const getBaseXEncoder = (alphabet: string): VariableSizeEncoder<string> => {\n    return createEncoder({\n        getSizeFromValue: (value: string): number => {\n            const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet[0]);\n            if (!tailChars) return value.length;\n\n            const base10Number = getBigIntFromBaseX(tailChars, alphabet);\n            return leadingZeroes.length + Math.ceil(base10Number.toString(16).length / 2);\n        },\n        write(value: string, bytes, offset) {\n            // Check if the value is valid.\n            assertValidBaseString(alphabet, value);\n            if (value === '') return offset;\n\n            // Handle leading zeroes.\n            const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet[0]);\n            if (!tailChars) {\n                bytes.set(new Uint8Array(leadingZeroes.length).fill(0), offset);\n                return offset + leadingZeroes.length;\n            }\n\n            // From baseX to base10.\n            let base10Number = getBigIntFromBaseX(tailChars, alphabet);\n\n            // From base10 to bytes.\n            const tailBytes: number[] = [];\n            while (base10Number > 0n) {\n                tailBytes.unshift(Number(base10Number % 256n));\n                base10Number /= 256n;\n            }\n\n            const bytesToAdd = [...Array(leadingZeroes.length).fill(0), ...tailBytes];\n            bytes.set(bytesToAdd, offset);\n            return offset + bytesToAdd.length;\n        },\n    });\n};\n\n/**\n * Returns a decoder for base-X encoded strings.\n *\n * This decoder deserializes base-X encoded strings from a byte array using a custom alphabet.\n * The decoding process converts the byte array into a numeric value in base-10, then\n * maps that value back to characters in the specified base-X alphabet.\n *\n * For more details, see {@link getBaseXCodec}.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @returns A `VariableSizeDecoder<string>` for decoding base-X strings.\n *\n * @example\n * Decoding a base-X string using a custom alphabet.\n * ```ts\n * const decoder = getBaseXDecoder('0123456789abcdef');\n * const value = decoder.decode(new Uint8Array([0xde, 0xad, 0xfa, 0xce])); // \"deadface\"\n * ```\n *\n * @see {@link getBaseXCodec}\n */\nexport const getBaseXDecoder = (alphabet: string): VariableSizeDecoder<string> => {\n    return createDecoder({\n        read(rawBytes, offset): [string, number] {\n            const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);\n            if (bytes.length === 0) return ['', 0];\n\n            // Handle leading zeroes.\n            let trailIndex = bytes.findIndex(n => n !== 0);\n            trailIndex = trailIndex === -1 ? bytes.length : trailIndex;\n            const leadingZeroes = alphabet[0].repeat(trailIndex);\n            if (trailIndex === bytes.length) return [leadingZeroes, rawBytes.length];\n\n            // From bytes to base10.\n            const base10Number = bytes.slice(trailIndex).reduce((sum, byte) => sum * 256n + BigInt(byte), 0n);\n\n            // From base10 to baseX.\n            const tailChars = getBaseXFromBigInt(base10Number, alphabet);\n\n            return [leadingZeroes + tailChars, rawBytes.length];\n        },\n    });\n};\n\n/**\n * Returns a codec for encoding and decoding base-X strings.\n *\n * This codec serializes strings using a custom alphabet, treating the length of the alphabet as the base.\n * The encoding process converts the input string into a numeric value in base-X, which is then encoded as bytes.\n * The decoding process reverses this transformation to reconstruct the original string.\n *\n * This codec supports leading zeroes by treating the first character of the alphabet as the zero character.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-X strings.\n *\n * @example\n * Encoding and decoding a base-X string using a custom alphabet.\n * ```ts\n * const codec = getBaseXCodec('0123456789abcdef');\n * const bytes = codec.encode('deadface'); // 0xdeadface\n * const value = codec.decode(bytes);      // \"deadface\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-X codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBaseXCodec('0123456789abcdef'), 8);\n * ```\n *\n * If you need a size-prefixed base-X codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBaseXCodec('0123456789abcdef'), getU32Codec());\n * ```\n *\n * Separate {@link getBaseXEncoder} and {@link getBaseXDecoder} functions are available.\n *\n * ```ts\n * const bytes = getBaseXEncoder('0123456789abcdef').encode('deadface');\n * const value = getBaseXDecoder('0123456789abcdef').decode(bytes);\n * ```\n *\n * @see {@link getBaseXEncoder}\n * @see {@link getBaseXDecoder}\n */\nexport const getBaseXCodec = (alphabet: string): VariableSizeCodec<string> =>\n    combineCodec(getBaseXEncoder(alphabet), getBaseXDecoder(alphabet));\n\nfunction partitionLeadingZeroes(\n    value: string,\n    zeroCharacter: string,\n): [leadingZeros: string, tailChars: string | undefined] {\n    const [leadingZeros, tailChars] = value.split(new RegExp(`((?!${zeroCharacter}).*)`));\n    return [leadingZeros, tailChars];\n}\n\nfunction getBigIntFromBaseX(value: string, alphabet: string): bigint {\n    const base = BigInt(alphabet.length);\n    let sum = 0n;\n    for (const char of value) {\n        sum *= base;\n        sum += BigInt(alphabet.indexOf(char));\n    }\n    return sum;\n}\n\nfunction getBaseXFromBigInt(value: bigint, alphabet: string): string {\n    const base = BigInt(alphabet.length);\n    const tailChars = [];\n    while (value > 0n) {\n        tailChars.unshift(alphabet[Number(value % base)]);\n        value /= base;\n    }\n    return tailChars.join('');\n}\n","import { getBaseXCodec, getBaseXDecoder, getBaseXEncoder } from './baseX';\n\nconst alphabet = '0123456789';\n\n/**\n * Returns an encoder for base-10 strings.\n *\n * This encoder serializes strings using a base-10 encoding scheme.\n * The output consists of bytes representing the numerical values of the input string.\n *\n * For more details, see {@link getBase10Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding base-10 strings.\n *\n * @example\n * Encoding a base-10 string.\n * ```ts\n * const encoder = getBase10Encoder();\n * const bytes = encoder.encode('1024'); // 0x0400\n * ```\n *\n * @see {@link getBase10Codec}\n */\nexport const getBase10Encoder = () => getBaseXEncoder(alphabet);\n\n/**\n * Returns a decoder for base-10 strings.\n *\n * This decoder deserializes base-10 encoded strings from a byte array.\n *\n * For more details, see {@link getBase10Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding base-10 strings.\n *\n * @example\n * Decoding a base-10 string.\n * ```ts\n * const decoder = getBase10Decoder();\n * const value = decoder.decode(new Uint8Array([0x04, 0x00])); // \"1024\"\n * ```\n *\n * @see {@link getBase10Codec}\n */\nexport const getBase10Decoder = () => getBaseXDecoder(alphabet);\n\n/**\n * Returns a codec for encoding and decoding base-10 strings.\n *\n * This codec serializes strings using a base-10 encoding scheme.\n * The output consists of bytes representing the numerical values of the input string.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-10 strings.\n *\n * @example\n * Encoding and decoding a base-10 string.\n * ```ts\n * const codec = getBase10Codec();\n * const bytes = codec.encode('1024'); // 0x0400\n * const value = codec.decode(bytes);  // \"1024\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-10 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBase10Codec(), 5);\n * ```\n *\n * If you need a size-prefixed base-10 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBase10Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getBase10Encoder} and {@link getBase10Decoder} functions are available.\n *\n * ```ts\n * const bytes = getBase10Encoder().encode('1024');\n * const value = getBase10Decoder().decode(bytes);\n * ```\n *\n * @see {@link getBase10Encoder}\n * @see {@link getBase10Decoder}\n */\nexport const getBase10Codec = () => getBaseXCodec(alphabet);\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\nconst enum HexC {\n    ZERO = 48, // 0\n    NINE = 57, // 9\n    A_UP = 65, // A\n    F_UP = 70, // F\n    A_LO = 97, // a\n    F_LO = 102, // f\n}\n\nconst INVALID_STRING_ERROR_BASE_CONFIG = {\n    alphabet: '0123456789abcdef',\n    base: 16,\n} as const;\n\nfunction charCodeToBase16(char: number) {\n    if (char >= HexC.ZERO && char <= HexC.NINE) return char - HexC.ZERO;\n    if (char >= HexC.A_UP && char <= HexC.F_UP) return char - (HexC.A_UP - 10);\n    if (char >= HexC.A_LO && char <= HexC.F_LO) return char - (HexC.A_LO - 10);\n}\n\n/**\n * Returns an encoder for base-16 (hexadecimal) strings.\n *\n * This encoder serializes strings using a base-16 encoding scheme.\n * The output consists of bytes representing the hexadecimal values of the input string.\n *\n * For more details, see {@link getBase16Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding base-16 strings.\n *\n * @example\n * Encoding a base-16 string.\n * ```ts\n * const encoder = getBase16Encoder();\n * const bytes = encoder.encode('deadface'); // 0xdeadface\n * ```\n *\n * @see {@link getBase16Codec}\n */\nexport const getBase16Encoder = (): VariableSizeEncoder<string> =>\n    createEncoder({\n        getSizeFromValue: (value: string) => Math.ceil(value.length / 2),\n        write(value: string, bytes, offset) {\n            const len = value.length;\n            const al = len / 2;\n            if (len === 1) {\n                const c = value.charCodeAt(0);\n                const n = charCodeToBase16(c);\n                if (n === undefined) {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        ...INVALID_STRING_ERROR_BASE_CONFIG,\n                        value,\n                    });\n                }\n                bytes.set([n], offset);\n                return 1 + offset;\n            }\n            const hexBytes = new Uint8Array(al);\n            for (let i = 0, j = 0; i < al; i++) {\n                const c1 = value.charCodeAt(j++);\n                const c2 = value.charCodeAt(j++);\n\n                const n1 = charCodeToBase16(c1);\n                const n2 = charCodeToBase16(c2);\n                if (n1 === undefined || (n2 === undefined && !Number.isNaN(c2))) {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        ...INVALID_STRING_ERROR_BASE_CONFIG,\n                        value,\n                    });\n                }\n                hexBytes[i] = !Number.isNaN(c2) ? (n1 << 4) | (n2 ?? 0) : n1;\n            }\n\n            bytes.set(hexBytes, offset);\n            return hexBytes.length + offset;\n        },\n    });\n\n/**\n * Returns a decoder for base-16 (hexadecimal) strings.\n *\n * This decoder deserializes base-16 encoded strings from a byte array.\n *\n * For more details, see {@link getBase16Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding base-16 strings.\n *\n * @example\n * Decoding a base-16 string.\n * ```ts\n * const decoder = getBase16Decoder();\n * const value = decoder.decode(new Uint8Array([0xde, 0xad, 0xfa, 0xce])); // \"deadface\"\n * ```\n *\n * @see {@link getBase16Codec}\n */\nexport const getBase16Decoder = (): VariableSizeDecoder<string> =>\n    createDecoder({\n        read(bytes, offset) {\n            const value = bytes.slice(offset).reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n            return [value, bytes.length];\n        },\n    });\n\n/**\n * Returns a codec for encoding and decoding base-16 (hexadecimal) strings.\n *\n * This codec serializes strings using a base-16 encoding scheme.\n * The output consists of bytes representing the hexadecimal values of the input string.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-16 strings.\n *\n * @example\n * Encoding and decoding a base-16 string.\n * ```ts\n * const codec = getBase16Codec();\n * const bytes = codec.encode('deadface'); // 0xdeadface\n * const value = codec.decode(bytes);      // \"deadface\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-16 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBase16Codec(), 8);\n * ```\n *\n * If you need a size-prefixed base-16 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBase16Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getBase16Encoder} and {@link getBase16Decoder} functions are available.\n *\n * ```ts\n * const bytes = getBase16Encoder().encode('deadface');\n * const value = getBase16Decoder().decode(bytes);\n * ```\n *\n * @see {@link getBase16Encoder}\n * @see {@link getBase16Decoder}\n */\nexport const getBase16Codec = (): VariableSizeCodec<string> => combineCodec(getBase16Encoder(), getBase16Decoder());\n","import { getBaseXCodec, getBaseXDecoder, getBaseXEncoder } from './baseX';\n\nconst alphabet = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\n\n/**\n * Returns an encoder for base-58 strings.\n *\n * This encoder serializes strings using a base-58 encoding scheme,\n * commonly used in cryptocurrency addresses and other compact representations.\n *\n * For more details, see {@link getBase58Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding base-58 strings.\n *\n * @example\n * Encoding a base-58 string.\n * ```ts\n * const encoder = getBase58Encoder();\n * const bytes = encoder.encode('heLLo'); // 0x1b6a3070\n * ```\n *\n * @see {@link getBase58Codec}\n */\nexport const getBase58Encoder = () => getBaseXEncoder(alphabet);\n\n/**\n * Returns a decoder for base-58 strings.\n *\n * This decoder deserializes base-58 encoded strings from a byte array.\n *\n * For more details, see {@link getBase58Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding base-58 strings.\n *\n * @example\n * Decoding a base-58 string.\n * ```ts\n * const decoder = getBase58Decoder();\n * const value = decoder.decode(new Uint8Array([0x1b, 0x6a, 0x30, 0x70])); // \"heLLo\"\n * ```\n *\n * @see {@link getBase58Codec}\n */\nexport const getBase58Decoder = () => getBaseXDecoder(alphabet);\n\n/**\n * Returns a codec for encoding and decoding base-58 strings.\n *\n * This codec serializes strings using a base-58 encoding scheme,\n * commonly used in cryptocurrency addresses and other compact representations.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-58 strings.\n *\n * @example\n * Encoding and decoding a base-58 string.\n * ```ts\n * const codec = getBase58Codec();\n * const bytes = codec.encode('heLLo'); // 0x1b6a3070\n * const value = codec.decode(bytes);   // \"heLLo\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-58 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBase58Codec(), 8);\n * ```\n *\n * If you need a size-prefixed base-58 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBase58Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getBase58Encoder} and {@link getBase58Decoder} functions are available.\n *\n * ```ts\n * const bytes = getBase58Encoder().encode('heLLo');\n * const value = getBase58Decoder().decode(bytes);\n * ```\n *\n * @see {@link getBase58Encoder}\n * @see {@link getBase58Decoder}\n */\nexport const getBase58Codec = () => getBaseXCodec(alphabet);\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertValidBaseString } from './assertions';\n\n/**\n * Returns an encoder for base-X encoded strings using bit re-slicing.\n *\n * This encoder serializes strings by dividing the input into custom-sized bit chunks,\n * mapping them to an alphabet, and encoding the result into a byte array.\n * This approach is commonly used for encoding schemes where the alphabet's length is a power of 2,\n * such as base-16 or base-64.\n *\n * For more details, see {@link getBaseXResliceCodec}.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @param bits - The number of bits per encoded chunk, typically `log2(alphabet.length)`.\n * @returns A `VariableSizeEncoder<string>` for encoding base-X strings using bit re-slicing.\n *\n * @example\n * Encoding a base-X string using bit re-slicing.\n * ```ts\n * const encoder = getBaseXResliceEncoder('elho', 2);\n * const bytes = encoder.encode('hellolol'); // 0x4aee\n * ```\n *\n * @see {@link getBaseXResliceCodec}\n */\nexport const getBaseXResliceEncoder = (alphabet: string, bits: number): VariableSizeEncoder<string> =>\n    createEncoder({\n        getSizeFromValue: (value: string) => Math.floor((value.length * bits) / 8),\n        write(value: string, bytes, offset) {\n            assertValidBaseString(alphabet, value);\n            if (value === '') return offset;\n            const charIndices = [...value].map(c => alphabet.indexOf(c));\n            const reslicedBytes = reslice(charIndices, bits, 8, false);\n            bytes.set(reslicedBytes, offset);\n            return reslicedBytes.length + offset;\n        },\n    });\n\n/**\n * Returns a decoder for base-X encoded strings using bit re-slicing.\n *\n * This decoder deserializes base-X encoded strings by re-slicing the bits of a byte array into\n * custom-sized chunks and mapping them to a specified alphabet.\n * This is typically used for encoding schemes where the alphabet's length is a power of 2,\n * such as base-16 or base-64.\n *\n * For more details, see {@link getBaseXResliceCodec}.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @param bits - The number of bits per encoded chunk, typically `log2(alphabet.length)`.\n * @returns A `VariableSizeDecoder<string>` for decoding base-X strings using bit re-slicing.\n *\n * @example\n * Decoding a base-X string using bit re-slicing.\n * ```ts\n * const decoder = getBaseXResliceDecoder('elho', 2);\n * const value = decoder.decode(new Uint8Array([0x4a, 0xee])); // \"hellolol\"\n * ```\n *\n * @see {@link getBaseXResliceCodec}\n */\nexport const getBaseXResliceDecoder = (alphabet: string, bits: number): VariableSizeDecoder<string> =>\n    createDecoder({\n        read(rawBytes, offset = 0): [string, number] {\n            const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);\n            if (bytes.length === 0) return ['', rawBytes.length];\n            const charIndices = reslice([...bytes], 8, bits, true);\n            return [charIndices.map(i => alphabet[i]).join(''), rawBytes.length];\n        },\n    });\n\n/**\n * Returns a codec for encoding and decoding base-X strings using bit re-slicing.\n *\n * This codec serializes strings by dividing the input into custom-sized bit chunks,\n * mapping them to a given alphabet, and encoding the result into bytes.\n * It is particularly suited for encoding schemes where the alphabet's length is a power of 2,\n * such as base-16 or base-64.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @param bits - The number of bits per encoded chunk, typically `log2(alphabet.length)`.\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-X strings using bit re-slicing.\n *\n * @example\n * Encoding and decoding a base-X string using bit re-slicing.\n * ```ts\n * const codec = getBaseXResliceCodec('elho', 2);\n * const bytes = codec.encode('hellolol'); // 0x4aee\n * const value = codec.decode(bytes);      // \"hellolol\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-X codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBaseXResliceCodec('elho', 2), 8);\n * ```\n *\n * If you need a size-prefixed base-X codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBaseXResliceCodec('elho', 2), getU32Codec());\n * ```\n *\n * Separate {@link getBaseXResliceEncoder} and {@link getBaseXResliceDecoder} functions are available.\n *\n * ```ts\n * const bytes = getBaseXResliceEncoder('elho', 2).encode('hellolol');\n * const value = getBaseXResliceDecoder('elho', 2).decode(bytes);\n * ```\n *\n * @see {@link getBaseXResliceEncoder}\n * @see {@link getBaseXResliceDecoder}\n */\nexport const getBaseXResliceCodec = (alphabet: string, bits: number): VariableSizeCodec<string> =>\n    combineCodec(getBaseXResliceEncoder(alphabet, bits), getBaseXResliceDecoder(alphabet, bits));\n\n/** Helper function to reslice the bits inside bytes. */\nfunction reslice(input: number[], inputBits: number, outputBits: number, useRemainder: boolean): number[] {\n    const output = [];\n    let accumulator = 0;\n    let bitsInAccumulator = 0;\n    const mask = (1 << outputBits) - 1;\n    for (const value of input) {\n        accumulator = (accumulator << inputBits) | value;\n        bitsInAccumulator += inputBits;\n        while (bitsInAccumulator >= outputBits) {\n            bitsInAccumulator -= outputBits;\n            output.push((accumulator >> bitsInAccumulator) & mask);\n        }\n    }\n    if (useRemainder && bitsInAccumulator > 0) {\n        output.push((accumulator << (outputBits - bitsInAccumulator)) & mask);\n    }\n    return output;\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\nimport { assertValidBaseString } from './assertions';\nimport { getBaseXResliceDecoder, getBaseXResliceEncoder } from './baseX-reslice';\n\nconst alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n/**\n * Returns an encoder for base-64 strings.\n *\n * This encoder serializes strings using a base-64 encoding scheme,\n * commonly used for data encoding in URLs, cryptographic keys, and binary-to-text encoding.\n *\n * For more details, see {@link getBase64Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding base-64 strings.\n *\n * @example\n * Encoding a base-64 string.\n * ```ts\n * const encoder = getBase64Encoder();\n * const bytes = encoder.encode('hello+world'); // 0x85e965a3ec28ae57\n * ```\n *\n * @see {@link getBase64Codec}\n */\nexport const getBase64Encoder = (): VariableSizeEncoder<string> => {\n    if (__BROWSER__) {\n        return createEncoder({\n            getSizeFromValue: (value: string) => {\n                try {\n                    return (atob as Window['atob'])(value).length;\n                } catch {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        alphabet,\n                        base: 64,\n                        value,\n                    });\n                }\n            },\n            write(value: string, bytes, offset) {\n                try {\n                    const bytesToAdd = (atob as Window['atob'])(value)\n                        .split('')\n                        .map(c => c.charCodeAt(0));\n                    bytes.set(bytesToAdd, offset);\n                    return bytesToAdd.length + offset;\n                } catch {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        alphabet,\n                        base: 64,\n                        value,\n                    });\n                }\n            },\n        });\n    }\n\n    if (__NODEJS__) {\n        return createEncoder({\n            getSizeFromValue: (value: string) => Buffer.from(value, 'base64').length,\n            write(value: string, bytes, offset) {\n                assertValidBaseString(alphabet, value.replace(/=/g, ''));\n                const buffer = Buffer.from(value, 'base64');\n                bytes.set(buffer, offset);\n                return buffer.length + offset;\n            },\n        });\n    }\n\n    return transformEncoder(getBaseXResliceEncoder(alphabet, 6), (value: string): string => value.replace(/=/g, ''));\n};\n\n/**\n * Returns a decoder for base-64 strings.\n *\n * This decoder deserializes base-64 encoded strings from a byte array.\n *\n * For more details, see {@link getBase64Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding base-64 strings.\n *\n * @example\n * Decoding a base-64 string.\n * ```ts\n * const decoder = getBase64Decoder();\n * const value = decoder.decode(new Uint8Array([0x85, 0xe9, 0x65, 0xa3, 0xec, 0x28, 0xae, 0x57])); // \"hello+world\"\n * ```\n *\n * @see {@link getBase64Codec}\n */\nexport const getBase64Decoder = (): VariableSizeDecoder<string> => {\n    if (__BROWSER__) {\n        return createDecoder({\n            read(bytes, offset = 0) {\n                const slice = bytes.slice(offset);\n                const value = (btoa as Window['btoa'])(String.fromCharCode(...slice));\n                return [value, bytes.length];\n            },\n        });\n    }\n\n    if (__NODEJS__) {\n        return createDecoder({\n            read: (bytes, offset = 0) => [Buffer.from(bytes, offset).toString('base64'), bytes.length],\n        });\n    }\n\n    return transformDecoder(getBaseXResliceDecoder(alphabet, 6), (value: string): string =>\n        value.padEnd(Math.ceil(value.length / 4) * 4, '='),\n    );\n};\n\n/**\n * Returns a codec for encoding and decoding base-64 strings.\n *\n * This codec serializes strings using a base-64 encoding scheme,\n * commonly used for data encoding in URLs, cryptographic keys, and binary-to-text encoding.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-64 strings.\n *\n * @example\n * Encoding and decoding a base-64 string.\n * ```ts\n * const codec = getBase64Codec();\n * const bytes = codec.encode('hello+world'); // 0x85e965a3ec28ae57\n * const value = codec.decode(bytes);         // \"hello+world\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-64 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBase64Codec(), 8);\n * ```\n *\n * If you need a size-prefixed base-64 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBase64Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getBase64Encoder} and {@link getBase64Decoder} functions are available.\n *\n * ```ts\n * const bytes = getBase64Encoder().encode('hello+world');\n * const value = getBase64Decoder().decode(bytes);\n * ```\n *\n * @see {@link getBase64Encoder}\n * @see {@link getBase64Decoder}\n */\nexport const getBase64Codec = (): VariableSizeCodec<string> => combineCodec(getBase64Encoder(), getBase64Decoder());\n","/**\n * Removes all null characters (`\\u0000`) from a string.\n *\n * This function cleans a string by stripping out any null characters,\n * which are often used as padding in fixed-size string encodings.\n *\n * @param value - The string to process.\n * @returns The input string with all null characters removed.\n *\n * @example\n * Removing null characters from a string.\n * ```ts\n * removeNullCharacters('hello\\u0000\\u0000'); // \"hello\"\n * ```\n */\nexport const removeNullCharacters = (value: string) =>\n    // eslint-disable-next-line no-control-regex\n    value.replace(/\\u0000/g, '');\n\n/**\n * Pads a string with null characters (`\\u0000`) at the end to reach a fixed length.\n *\n * If the input string is shorter than the specified length, it is padded with null characters\n * until it reaches the desired size. If it is already long enough, it remains unchanged.\n *\n * @param value - The string to pad.\n * @param chars - The total length of the resulting string, including padding.\n * @returns The input string padded with null characters up to the specified length.\n *\n * @example\n * Padding a string with null characters.\n * ```ts\n * padNullCharacters('hello', 8); // \"hello\\u0000\\u0000\\u0000\"\n * ```\n */\nexport const padNullCharacters = (value: string, chars: number) => value.padEnd(chars, '\\u0000');\n","export const TextDecoder = globalThis.TextDecoder;\nexport const TextEncoder = globalThis.TextEncoder;\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { TextDecoder, TextEncoder } from '@solana/text-encoding-impl';\n\nimport { removeNullCharacters } from './null-characters';\n\n/**\n * Returns an encoder for UTF-8 strings.\n *\n * This encoder serializes strings using UTF-8 encoding.\n * The encoded output contains as many bytes as needed to represent the string.\n *\n * For more details, see {@link getUtf8Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding UTF-8 strings.\n *\n * @example\n * Encoding a UTF-8 string.\n * ```ts\n * const encoder = getUtf8Encoder();\n * const bytes = encoder.encode('hello'); // 0x68656c6c6f\n * ```\n *\n * @see {@link getUtf8Codec}\n */\nexport const getUtf8Encoder = (): VariableSizeEncoder<string> => {\n    let textEncoder: TextEncoder;\n    return createEncoder({\n        getSizeFromValue: value => (textEncoder ||= new TextEncoder()).encode(value).length,\n        write: (value: string, bytes, offset) => {\n            const bytesToAdd = (textEncoder ||= new TextEncoder()).encode(value);\n            bytes.set(bytesToAdd, offset);\n            return offset + bytesToAdd.length;\n        },\n    });\n};\n\n/**\n * Returns a decoder for UTF-8 strings.\n *\n * This decoder deserializes UTF-8 encoded strings from a byte array.\n * It reads all available bytes starting from the given offset.\n *\n * For more details, see {@link getUtf8Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding UTF-8 strings.\n *\n * @example\n * Decoding a UTF-8 string.\n * ```ts\n * const decoder = getUtf8Decoder();\n * const value = decoder.decode(new Uint8Array([0x68, 0x65, 0x6c, 0x6c, 0x6f])); // \"hello\"\n * ```\n *\n * @see {@link getUtf8Codec}\n */\nexport const getUtf8Decoder = (): VariableSizeDecoder<string> => {\n    let textDecoder: TextDecoder;\n    return createDecoder({\n        read(bytes, offset) {\n            const value = (textDecoder ||= new TextDecoder()).decode(bytes.slice(offset));\n            return [removeNullCharacters(value), bytes.length];\n        },\n    });\n};\n\n/**\n * Returns a codec for encoding and decoding UTF-8 strings.\n *\n * This codec serializes strings using UTF-8 encoding.\n * The encoded output contains as many bytes as needed to represent the string.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding UTF-8 strings.\n *\n * @example\n * Encoding and decoding a UTF-8 string.\n * ```ts\n * const codec = getUtf8Codec();\n * const bytes = codec.encode('hello'); // 0x68656c6c6f\n * const value = codec.decode(bytes);   // \"hello\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size UTF-8 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getUtf8Codec(), 5);\n * ```\n *\n * If you need a size-prefixed UTF-8 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getUtf8Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getUtf8Encoder} and {@link getUtf8Decoder} functions are available.\n *\n * ```ts\n * const bytes = getUtf8Encoder().encode('hello');\n * const value = getUtf8Decoder().decode(bytes);\n * ```\n *\n * @see {@link getUtf8Encoder}\n * @see {@link getUtf8Decoder}\n */\nexport const getUtf8Codec = (): VariableSizeCodec<string> => combineCodec(getUtf8Encoder(), getUtf8Decoder());\n"],"names":["alphabet","createEncoder","SolanaError","SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE","createDecoder","combineCodec","TextDecoder","TextEncoder"],"mappings":"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","debugId":null}},
    {"offset": {"line": 2092, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/codecs/node_modules/@solana/codecs-strings/dist/index.browser.mjs","sources":["file:///Users/ivaylobakalov/web3/solana/voting-dapp/frontend/node_modules/%40solana/codecs/node_modules/%40solana/codecs-strings/src/assertions.ts","file:///Users/ivaylobakalov/web3/solana/voting-dapp/frontend/node_modules/%40solana/codecs/node_modules/%40solana/codecs-strings/src/baseX.ts","file:///Users/ivaylobakalov/web3/solana/voting-dapp/frontend/node_modules/%40solana/codecs/node_modules/%40solana/codecs-strings/src/base10.ts","file:///Users/ivaylobakalov/web3/solana/voting-dapp/frontend/node_modules/%40solana/codecs/node_modules/%40solana/codecs-strings/src/base16.ts","file:///Users/ivaylobakalov/web3/solana/voting-dapp/frontend/node_modules/%40solana/codecs/node_modules/%40solana/codecs-strings/src/base58.ts","file:///Users/ivaylobakalov/web3/solana/voting-dapp/frontend/node_modules/%40solana/codecs/node_modules/%40solana/codecs-strings/src/baseX-reslice.ts","file:///Users/ivaylobakalov/web3/solana/voting-dapp/frontend/node_modules/%40solana/codecs/node_modules/%40solana/codecs-strings/src/base64.ts","file:///Users/ivaylobakalov/web3/solana/voting-dapp/frontend/node_modules/%40solana/codecs/node_modules/%40solana/codecs-strings/src/null-characters.ts","file:///Users/ivaylobakalov/web3/solana/voting-dapp/frontend/node_modules/%40solana/codecs/node_modules/%40solana/text-encoding-impl/src/index.browser.ts","file:///Users/ivaylobakalov/web3/solana/voting-dapp/frontend/node_modules/%40solana/codecs/node_modules/%40solana/codecs-strings/src/utf8.ts"],"sourcesContent":["import { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\n/**\n * Asserts that a given string contains only characters from the specified alphabet.\n *\n * This function validates whether a string consists exclusively of characters\n * from the provided `alphabet`. If the validation fails, it throws an error\n * indicating the invalid base string.\n *\n * @param alphabet - The allowed set of characters for the base encoding.\n * @param testValue - The string to validate against the given alphabet.\n * @param givenValue - The original string provided by the user (defaults to `testValue`).\n *\n * @throws {SolanaError} If `testValue` contains characters not present in `alphabet`.\n *\n * @example\n * Validating a base-8 encoded string.\n * ```ts\n * assertValidBaseString('01234567', '123047'); // Passes\n * assertValidBaseString('01234567', '128');    // Throws error\n * ```\n */\nexport function assertValidBaseString(alphabet: string, testValue: string, givenValue = testValue) {\n    if (!testValue.match(new RegExp(`^[${alphabet}]*$`))) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n            alphabet,\n            base: alphabet.length,\n            value: givenValue,\n        });\n    }\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertValidBaseString } from './assertions';\n\n/**\n * Returns an encoder for base-X encoded strings.\n *\n * This encoder serializes strings using a custom alphabet, treating the length of the alphabet as the base.\n * The encoding process involves converting the input string to a numeric value in base-X, then\n * encoding that value into bytes while preserving leading zeroes.\n *\n * For more details, see {@link getBaseXCodec}.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @returns A `VariableSizeEncoder<string>` for encoding base-X strings.\n *\n * @example\n * Encoding a base-X string using a custom alphabet.\n * ```ts\n * const encoder = getBaseXEncoder('0123456789abcdef');\n * const bytes = encoder.encode('deadface'); // 0xdeadface\n * ```\n *\n * @see {@link getBaseXCodec}\n */\nexport const getBaseXEncoder = (alphabet: string): VariableSizeEncoder<string> => {\n    return createEncoder({\n        getSizeFromValue: (value: string): number => {\n            const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet[0]);\n            if (!tailChars) return value.length;\n\n            const base10Number = getBigIntFromBaseX(tailChars, alphabet);\n            return leadingZeroes.length + Math.ceil(base10Number.toString(16).length / 2);\n        },\n        write(value: string, bytes, offset) {\n            // Check if the value is valid.\n            assertValidBaseString(alphabet, value);\n            if (value === '') return offset;\n\n            // Handle leading zeroes.\n            const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet[0]);\n            if (!tailChars) {\n                bytes.set(new Uint8Array(leadingZeroes.length).fill(0), offset);\n                return offset + leadingZeroes.length;\n            }\n\n            // From baseX to base10.\n            let base10Number = getBigIntFromBaseX(tailChars, alphabet);\n\n            // From base10 to bytes.\n            const tailBytes: number[] = [];\n            while (base10Number > 0n) {\n                tailBytes.unshift(Number(base10Number % 256n));\n                base10Number /= 256n;\n            }\n\n            const bytesToAdd = [...Array(leadingZeroes.length).fill(0), ...tailBytes];\n            bytes.set(bytesToAdd, offset);\n            return offset + bytesToAdd.length;\n        },\n    });\n};\n\n/**\n * Returns a decoder for base-X encoded strings.\n *\n * This decoder deserializes base-X encoded strings from a byte array using a custom alphabet.\n * The decoding process converts the byte array into a numeric value in base-10, then\n * maps that value back to characters in the specified base-X alphabet.\n *\n * For more details, see {@link getBaseXCodec}.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @returns A `VariableSizeDecoder<string>` for decoding base-X strings.\n *\n * @example\n * Decoding a base-X string using a custom alphabet.\n * ```ts\n * const decoder = getBaseXDecoder('0123456789abcdef');\n * const value = decoder.decode(new Uint8Array([0xde, 0xad, 0xfa, 0xce])); // \"deadface\"\n * ```\n *\n * @see {@link getBaseXCodec}\n */\nexport const getBaseXDecoder = (alphabet: string): VariableSizeDecoder<string> => {\n    return createDecoder({\n        read(rawBytes, offset): [string, number] {\n            const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);\n            if (bytes.length === 0) return ['', 0];\n\n            // Handle leading zeroes.\n            let trailIndex = bytes.findIndex(n => n !== 0);\n            trailIndex = trailIndex === -1 ? bytes.length : trailIndex;\n            const leadingZeroes = alphabet[0].repeat(trailIndex);\n            if (trailIndex === bytes.length) return [leadingZeroes, rawBytes.length];\n\n            // From bytes to base10.\n            const base10Number = bytes.slice(trailIndex).reduce((sum, byte) => sum * 256n + BigInt(byte), 0n);\n\n            // From base10 to baseX.\n            const tailChars = getBaseXFromBigInt(base10Number, alphabet);\n\n            return [leadingZeroes + tailChars, rawBytes.length];\n        },\n    });\n};\n\n/**\n * Returns a codec for encoding and decoding base-X strings.\n *\n * This codec serializes strings using a custom alphabet, treating the length of the alphabet as the base.\n * The encoding process converts the input string into a numeric value in base-X, which is then encoded as bytes.\n * The decoding process reverses this transformation to reconstruct the original string.\n *\n * This codec supports leading zeroes by treating the first character of the alphabet as the zero character.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-X strings.\n *\n * @example\n * Encoding and decoding a base-X string using a custom alphabet.\n * ```ts\n * const codec = getBaseXCodec('0123456789abcdef');\n * const bytes = codec.encode('deadface'); // 0xdeadface\n * const value = codec.decode(bytes);      // \"deadface\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-X codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBaseXCodec('0123456789abcdef'), 8);\n * ```\n *\n * If you need a size-prefixed base-X codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBaseXCodec('0123456789abcdef'), getU32Codec());\n * ```\n *\n * Separate {@link getBaseXEncoder} and {@link getBaseXDecoder} functions are available.\n *\n * ```ts\n * const bytes = getBaseXEncoder('0123456789abcdef').encode('deadface');\n * const value = getBaseXDecoder('0123456789abcdef').decode(bytes);\n * ```\n *\n * @see {@link getBaseXEncoder}\n * @see {@link getBaseXDecoder}\n */\nexport const getBaseXCodec = (alphabet: string): VariableSizeCodec<string> =>\n    combineCodec(getBaseXEncoder(alphabet), getBaseXDecoder(alphabet));\n\nfunction partitionLeadingZeroes(\n    value: string,\n    zeroCharacter: string,\n): [leadingZeros: string, tailChars: string | undefined] {\n    const [leadingZeros, tailChars] = value.split(new RegExp(`((?!${zeroCharacter}).*)`));\n    return [leadingZeros, tailChars];\n}\n\nfunction getBigIntFromBaseX(value: string, alphabet: string): bigint {\n    const base = BigInt(alphabet.length);\n    let sum = 0n;\n    for (const char of value) {\n        sum *= base;\n        sum += BigInt(alphabet.indexOf(char));\n    }\n    return sum;\n}\n\nfunction getBaseXFromBigInt(value: bigint, alphabet: string): string {\n    const base = BigInt(alphabet.length);\n    const tailChars = [];\n    while (value > 0n) {\n        tailChars.unshift(alphabet[Number(value % base)]);\n        value /= base;\n    }\n    return tailChars.join('');\n}\n","import { getBaseXCodec, getBaseXDecoder, getBaseXEncoder } from './baseX';\n\nconst alphabet = '0123456789';\n\n/**\n * Returns an encoder for base-10 strings.\n *\n * This encoder serializes strings using a base-10 encoding scheme.\n * The output consists of bytes representing the numerical values of the input string.\n *\n * For more details, see {@link getBase10Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding base-10 strings.\n *\n * @example\n * Encoding a base-10 string.\n * ```ts\n * const encoder = getBase10Encoder();\n * const bytes = encoder.encode('1024'); // 0x0400\n * ```\n *\n * @see {@link getBase10Codec}\n */\nexport const getBase10Encoder = () => getBaseXEncoder(alphabet);\n\n/**\n * Returns a decoder for base-10 strings.\n *\n * This decoder deserializes base-10 encoded strings from a byte array.\n *\n * For more details, see {@link getBase10Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding base-10 strings.\n *\n * @example\n * Decoding a base-10 string.\n * ```ts\n * const decoder = getBase10Decoder();\n * const value = decoder.decode(new Uint8Array([0x04, 0x00])); // \"1024\"\n * ```\n *\n * @see {@link getBase10Codec}\n */\nexport const getBase10Decoder = () => getBaseXDecoder(alphabet);\n\n/**\n * Returns a codec for encoding and decoding base-10 strings.\n *\n * This codec serializes strings using a base-10 encoding scheme.\n * The output consists of bytes representing the numerical values of the input string.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-10 strings.\n *\n * @example\n * Encoding and decoding a base-10 string.\n * ```ts\n * const codec = getBase10Codec();\n * const bytes = codec.encode('1024'); // 0x0400\n * const value = codec.decode(bytes);  // \"1024\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-10 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBase10Codec(), 5);\n * ```\n *\n * If you need a size-prefixed base-10 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBase10Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getBase10Encoder} and {@link getBase10Decoder} functions are available.\n *\n * ```ts\n * const bytes = getBase10Encoder().encode('1024');\n * const value = getBase10Decoder().decode(bytes);\n * ```\n *\n * @see {@link getBase10Encoder}\n * @see {@link getBase10Decoder}\n */\nexport const getBase10Codec = () => getBaseXCodec(alphabet);\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\nconst enum HexC {\n    ZERO = 48, // 0\n    NINE = 57, // 9\n    A_UP = 65, // A\n    F_UP = 70, // F\n    A_LO = 97, // a\n    F_LO = 102, // f\n}\n\nconst INVALID_STRING_ERROR_BASE_CONFIG = {\n    alphabet: '0123456789abcdef',\n    base: 16,\n} as const;\n\nfunction charCodeToBase16(char: number) {\n    if (char >= HexC.ZERO && char <= HexC.NINE) return char - HexC.ZERO;\n    if (char >= HexC.A_UP && char <= HexC.F_UP) return char - (HexC.A_UP - 10);\n    if (char >= HexC.A_LO && char <= HexC.F_LO) return char - (HexC.A_LO - 10);\n}\n\n/**\n * Returns an encoder for base-16 (hexadecimal) strings.\n *\n * This encoder serializes strings using a base-16 encoding scheme.\n * The output consists of bytes representing the hexadecimal values of the input string.\n *\n * For more details, see {@link getBase16Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding base-16 strings.\n *\n * @example\n * Encoding a base-16 string.\n * ```ts\n * const encoder = getBase16Encoder();\n * const bytes = encoder.encode('deadface'); // 0xdeadface\n * ```\n *\n * @see {@link getBase16Codec}\n */\nexport const getBase16Encoder = (): VariableSizeEncoder<string> =>\n    createEncoder({\n        getSizeFromValue: (value: string) => Math.ceil(value.length / 2),\n        write(value: string, bytes, offset) {\n            const len = value.length;\n            const al = len / 2;\n            if (len === 1) {\n                const c = value.charCodeAt(0);\n                const n = charCodeToBase16(c);\n                if (n === undefined) {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        ...INVALID_STRING_ERROR_BASE_CONFIG,\n                        value,\n                    });\n                }\n                bytes.set([n], offset);\n                return 1 + offset;\n            }\n            const hexBytes = new Uint8Array(al);\n            for (let i = 0, j = 0; i < al; i++) {\n                const c1 = value.charCodeAt(j++);\n                const c2 = value.charCodeAt(j++);\n\n                const n1 = charCodeToBase16(c1);\n                const n2 = charCodeToBase16(c2);\n                if (n1 === undefined || (n2 === undefined && !Number.isNaN(c2))) {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        ...INVALID_STRING_ERROR_BASE_CONFIG,\n                        value,\n                    });\n                }\n                hexBytes[i] = !Number.isNaN(c2) ? (n1 << 4) | (n2 ?? 0) : n1;\n            }\n\n            bytes.set(hexBytes, offset);\n            return hexBytes.length + offset;\n        },\n    });\n\n/**\n * Returns a decoder for base-16 (hexadecimal) strings.\n *\n * This decoder deserializes base-16 encoded strings from a byte array.\n *\n * For more details, see {@link getBase16Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding base-16 strings.\n *\n * @example\n * Decoding a base-16 string.\n * ```ts\n * const decoder = getBase16Decoder();\n * const value = decoder.decode(new Uint8Array([0xde, 0xad, 0xfa, 0xce])); // \"deadface\"\n * ```\n *\n * @see {@link getBase16Codec}\n */\nexport const getBase16Decoder = (): VariableSizeDecoder<string> =>\n    createDecoder({\n        read(bytes, offset) {\n            const value = bytes.slice(offset).reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n            return [value, bytes.length];\n        },\n    });\n\n/**\n * Returns a codec for encoding and decoding base-16 (hexadecimal) strings.\n *\n * This codec serializes strings using a base-16 encoding scheme.\n * The output consists of bytes representing the hexadecimal values of the input string.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-16 strings.\n *\n * @example\n * Encoding and decoding a base-16 string.\n * ```ts\n * const codec = getBase16Codec();\n * const bytes = codec.encode('deadface'); // 0xdeadface\n * const value = codec.decode(bytes);      // \"deadface\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-16 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBase16Codec(), 8);\n * ```\n *\n * If you need a size-prefixed base-16 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBase16Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getBase16Encoder} and {@link getBase16Decoder} functions are available.\n *\n * ```ts\n * const bytes = getBase16Encoder().encode('deadface');\n * const value = getBase16Decoder().decode(bytes);\n * ```\n *\n * @see {@link getBase16Encoder}\n * @see {@link getBase16Decoder}\n */\nexport const getBase16Codec = (): VariableSizeCodec<string> => combineCodec(getBase16Encoder(), getBase16Decoder());\n","import { getBaseXCodec, getBaseXDecoder, getBaseXEncoder } from './baseX';\n\nconst alphabet = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\n\n/**\n * Returns an encoder for base-58 strings.\n *\n * This encoder serializes strings using a base-58 encoding scheme,\n * commonly used in cryptocurrency addresses and other compact representations.\n *\n * For more details, see {@link getBase58Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding base-58 strings.\n *\n * @example\n * Encoding a base-58 string.\n * ```ts\n * const encoder = getBase58Encoder();\n * const bytes = encoder.encode('heLLo'); // 0x1b6a3070\n * ```\n *\n * @see {@link getBase58Codec}\n */\nexport const getBase58Encoder = () => getBaseXEncoder(alphabet);\n\n/**\n * Returns a decoder for base-58 strings.\n *\n * This decoder deserializes base-58 encoded strings from a byte array.\n *\n * For more details, see {@link getBase58Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding base-58 strings.\n *\n * @example\n * Decoding a base-58 string.\n * ```ts\n * const decoder = getBase58Decoder();\n * const value = decoder.decode(new Uint8Array([0x1b, 0x6a, 0x30, 0x70])); // \"heLLo\"\n * ```\n *\n * @see {@link getBase58Codec}\n */\nexport const getBase58Decoder = () => getBaseXDecoder(alphabet);\n\n/**\n * Returns a codec for encoding and decoding base-58 strings.\n *\n * This codec serializes strings using a base-58 encoding scheme,\n * commonly used in cryptocurrency addresses and other compact representations.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-58 strings.\n *\n * @example\n * Encoding and decoding a base-58 string.\n * ```ts\n * const codec = getBase58Codec();\n * const bytes = codec.encode('heLLo'); // 0x1b6a3070\n * const value = codec.decode(bytes);   // \"heLLo\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-58 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBase58Codec(), 8);\n * ```\n *\n * If you need a size-prefixed base-58 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBase58Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getBase58Encoder} and {@link getBase58Decoder} functions are available.\n *\n * ```ts\n * const bytes = getBase58Encoder().encode('heLLo');\n * const value = getBase58Decoder().decode(bytes);\n * ```\n *\n * @see {@link getBase58Encoder}\n * @see {@link getBase58Decoder}\n */\nexport const getBase58Codec = () => getBaseXCodec(alphabet);\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertValidBaseString } from './assertions';\n\n/**\n * Returns an encoder for base-X encoded strings using bit re-slicing.\n *\n * This encoder serializes strings by dividing the input into custom-sized bit chunks,\n * mapping them to an alphabet, and encoding the result into a byte array.\n * This approach is commonly used for encoding schemes where the alphabet's length is a power of 2,\n * such as base-16 or base-64.\n *\n * For more details, see {@link getBaseXResliceCodec}.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @param bits - The number of bits per encoded chunk, typically `log2(alphabet.length)`.\n * @returns A `VariableSizeEncoder<string>` for encoding base-X strings using bit re-slicing.\n *\n * @example\n * Encoding a base-X string using bit re-slicing.\n * ```ts\n * const encoder = getBaseXResliceEncoder('elho', 2);\n * const bytes = encoder.encode('hellolol'); // 0x4aee\n * ```\n *\n * @see {@link getBaseXResliceCodec}\n */\nexport const getBaseXResliceEncoder = (alphabet: string, bits: number): VariableSizeEncoder<string> =>\n    createEncoder({\n        getSizeFromValue: (value: string) => Math.floor((value.length * bits) / 8),\n        write(value: string, bytes, offset) {\n            assertValidBaseString(alphabet, value);\n            if (value === '') return offset;\n            const charIndices = [...value].map(c => alphabet.indexOf(c));\n            const reslicedBytes = reslice(charIndices, bits, 8, false);\n            bytes.set(reslicedBytes, offset);\n            return reslicedBytes.length + offset;\n        },\n    });\n\n/**\n * Returns a decoder for base-X encoded strings using bit re-slicing.\n *\n * This decoder deserializes base-X encoded strings by re-slicing the bits of a byte array into\n * custom-sized chunks and mapping them to a specified alphabet.\n * This is typically used for encoding schemes where the alphabet's length is a power of 2,\n * such as base-16 or base-64.\n *\n * For more details, see {@link getBaseXResliceCodec}.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @param bits - The number of bits per encoded chunk, typically `log2(alphabet.length)`.\n * @returns A `VariableSizeDecoder<string>` for decoding base-X strings using bit re-slicing.\n *\n * @example\n * Decoding a base-X string using bit re-slicing.\n * ```ts\n * const decoder = getBaseXResliceDecoder('elho', 2);\n * const value = decoder.decode(new Uint8Array([0x4a, 0xee])); // \"hellolol\"\n * ```\n *\n * @see {@link getBaseXResliceCodec}\n */\nexport const getBaseXResliceDecoder = (alphabet: string, bits: number): VariableSizeDecoder<string> =>\n    createDecoder({\n        read(rawBytes, offset = 0): [string, number] {\n            const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);\n            if (bytes.length === 0) return ['', rawBytes.length];\n            const charIndices = reslice([...bytes], 8, bits, true);\n            return [charIndices.map(i => alphabet[i]).join(''), rawBytes.length];\n        },\n    });\n\n/**\n * Returns a codec for encoding and decoding base-X strings using bit re-slicing.\n *\n * This codec serializes strings by dividing the input into custom-sized bit chunks,\n * mapping them to a given alphabet, and encoding the result into bytes.\n * It is particularly suited for encoding schemes where the alphabet's length is a power of 2,\n * such as base-16 or base-64.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @param bits - The number of bits per encoded chunk, typically `log2(alphabet.length)`.\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-X strings using bit re-slicing.\n *\n * @example\n * Encoding and decoding a base-X string using bit re-slicing.\n * ```ts\n * const codec = getBaseXResliceCodec('elho', 2);\n * const bytes = codec.encode('hellolol'); // 0x4aee\n * const value = codec.decode(bytes);      // \"hellolol\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-X codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBaseXResliceCodec('elho', 2), 8);\n * ```\n *\n * If you need a size-prefixed base-X codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBaseXResliceCodec('elho', 2), getU32Codec());\n * ```\n *\n * Separate {@link getBaseXResliceEncoder} and {@link getBaseXResliceDecoder} functions are available.\n *\n * ```ts\n * const bytes = getBaseXResliceEncoder('elho', 2).encode('hellolol');\n * const value = getBaseXResliceDecoder('elho', 2).decode(bytes);\n * ```\n *\n * @see {@link getBaseXResliceEncoder}\n * @see {@link getBaseXResliceDecoder}\n */\nexport const getBaseXResliceCodec = (alphabet: string, bits: number): VariableSizeCodec<string> =>\n    combineCodec(getBaseXResliceEncoder(alphabet, bits), getBaseXResliceDecoder(alphabet, bits));\n\n/** Helper function to reslice the bits inside bytes. */\nfunction reslice(input: number[], inputBits: number, outputBits: number, useRemainder: boolean): number[] {\n    const output = [];\n    let accumulator = 0;\n    let bitsInAccumulator = 0;\n    const mask = (1 << outputBits) - 1;\n    for (const value of input) {\n        accumulator = (accumulator << inputBits) | value;\n        bitsInAccumulator += inputBits;\n        while (bitsInAccumulator >= outputBits) {\n            bitsInAccumulator -= outputBits;\n            output.push((accumulator >> bitsInAccumulator) & mask);\n        }\n    }\n    if (useRemainder && bitsInAccumulator > 0) {\n        output.push((accumulator << (outputBits - bitsInAccumulator)) & mask);\n    }\n    return output;\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\nimport { assertValidBaseString } from './assertions';\nimport { getBaseXResliceDecoder, getBaseXResliceEncoder } from './baseX-reslice';\n\nconst alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n/**\n * Returns an encoder for base-64 strings.\n *\n * This encoder serializes strings using a base-64 encoding scheme,\n * commonly used for data encoding in URLs, cryptographic keys, and binary-to-text encoding.\n *\n * For more details, see {@link getBase64Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding base-64 strings.\n *\n * @example\n * Encoding a base-64 string.\n * ```ts\n * const encoder = getBase64Encoder();\n * const bytes = encoder.encode('hello+world'); // 0x85e965a3ec28ae57\n * ```\n *\n * @see {@link getBase64Codec}\n */\nexport const getBase64Encoder = (): VariableSizeEncoder<string> => {\n    if (__BROWSER__) {\n        return createEncoder({\n            getSizeFromValue: (value: string) => {\n                try {\n                    return (atob as Window['atob'])(value).length;\n                } catch {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        alphabet,\n                        base: 64,\n                        value,\n                    });\n                }\n            },\n            write(value: string, bytes, offset) {\n                try {\n                    const bytesToAdd = (atob as Window['atob'])(value)\n                        .split('')\n                        .map(c => c.charCodeAt(0));\n                    bytes.set(bytesToAdd, offset);\n                    return bytesToAdd.length + offset;\n                } catch {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        alphabet,\n                        base: 64,\n                        value,\n                    });\n                }\n            },\n        });\n    }\n\n    if (__NODEJS__) {\n        return createEncoder({\n            getSizeFromValue: (value: string) => Buffer.from(value, 'base64').length,\n            write(value: string, bytes, offset) {\n                assertValidBaseString(alphabet, value.replace(/=/g, ''));\n                const buffer = Buffer.from(value, 'base64');\n                bytes.set(buffer, offset);\n                return buffer.length + offset;\n            },\n        });\n    }\n\n    return transformEncoder(getBaseXResliceEncoder(alphabet, 6), (value: string): string => value.replace(/=/g, ''));\n};\n\n/**\n * Returns a decoder for base-64 strings.\n *\n * This decoder deserializes base-64 encoded strings from a byte array.\n *\n * For more details, see {@link getBase64Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding base-64 strings.\n *\n * @example\n * Decoding a base-64 string.\n * ```ts\n * const decoder = getBase64Decoder();\n * const value = decoder.decode(new Uint8Array([0x85, 0xe9, 0x65, 0xa3, 0xec, 0x28, 0xae, 0x57])); // \"hello+world\"\n * ```\n *\n * @see {@link getBase64Codec}\n */\nexport const getBase64Decoder = (): VariableSizeDecoder<string> => {\n    if (__BROWSER__) {\n        return createDecoder({\n            read(bytes, offset = 0) {\n                const slice = bytes.slice(offset);\n                const value = (btoa as Window['btoa'])(String.fromCharCode(...slice));\n                return [value, bytes.length];\n            },\n        });\n    }\n\n    if (__NODEJS__) {\n        return createDecoder({\n            read: (bytes, offset = 0) => [Buffer.from(bytes, offset).toString('base64'), bytes.length],\n        });\n    }\n\n    return transformDecoder(getBaseXResliceDecoder(alphabet, 6), (value: string): string =>\n        value.padEnd(Math.ceil(value.length / 4) * 4, '='),\n    );\n};\n\n/**\n * Returns a codec for encoding and decoding base-64 strings.\n *\n * This codec serializes strings using a base-64 encoding scheme,\n * commonly used for data encoding in URLs, cryptographic keys, and binary-to-text encoding.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-64 strings.\n *\n * @example\n * Encoding and decoding a base-64 string.\n * ```ts\n * const codec = getBase64Codec();\n * const bytes = codec.encode('hello+world'); // 0x85e965a3ec28ae57\n * const value = codec.decode(bytes);         // \"hello+world\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-64 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBase64Codec(), 8);\n * ```\n *\n * If you need a size-prefixed base-64 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBase64Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getBase64Encoder} and {@link getBase64Decoder} functions are available.\n *\n * ```ts\n * const bytes = getBase64Encoder().encode('hello+world');\n * const value = getBase64Decoder().decode(bytes);\n * ```\n *\n * @see {@link getBase64Encoder}\n * @see {@link getBase64Decoder}\n */\nexport const getBase64Codec = (): VariableSizeCodec<string> => combineCodec(getBase64Encoder(), getBase64Decoder());\n","/**\n * Removes all null characters (`\\u0000`) from a string.\n *\n * This function cleans a string by stripping out any null characters,\n * which are often used as padding in fixed-size string encodings.\n *\n * @param value - The string to process.\n * @returns The input string with all null characters removed.\n *\n * @example\n * Removing null characters from a string.\n * ```ts\n * removeNullCharacters('hello\\u0000\\u0000'); // \"hello\"\n * ```\n */\nexport const removeNullCharacters = (value: string) =>\n    // eslint-disable-next-line no-control-regex\n    value.replace(/\\u0000/g, '');\n\n/**\n * Pads a string with null characters (`\\u0000`) at the end to reach a fixed length.\n *\n * If the input string is shorter than the specified length, it is padded with null characters\n * until it reaches the desired size. If it is already long enough, it remains unchanged.\n *\n * @param value - The string to pad.\n * @param chars - The total length of the resulting string, including padding.\n * @returns The input string padded with null characters up to the specified length.\n *\n * @example\n * Padding a string with null characters.\n * ```ts\n * padNullCharacters('hello', 8); // \"hello\\u0000\\u0000\\u0000\"\n * ```\n */\nexport const padNullCharacters = (value: string, chars: number) => value.padEnd(chars, '\\u0000');\n","export const TextDecoder = globalThis.TextDecoder;\nexport const TextEncoder = globalThis.TextEncoder;\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { TextDecoder, TextEncoder } from '@solana/text-encoding-impl';\n\nimport { removeNullCharacters } from './null-characters';\n\n/**\n * Returns an encoder for UTF-8 strings.\n *\n * This encoder serializes strings using UTF-8 encoding.\n * The encoded output contains as many bytes as needed to represent the string.\n *\n * For more details, see {@link getUtf8Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding UTF-8 strings.\n *\n * @example\n * Encoding a UTF-8 string.\n * ```ts\n * const encoder = getUtf8Encoder();\n * const bytes = encoder.encode('hello'); // 0x68656c6c6f\n * ```\n *\n * @see {@link getUtf8Codec}\n */\nexport const getUtf8Encoder = (): VariableSizeEncoder<string> => {\n    let textEncoder: TextEncoder;\n    return createEncoder({\n        getSizeFromValue: value => (textEncoder ||= new TextEncoder()).encode(value).length,\n        write: (value: string, bytes, offset) => {\n            const bytesToAdd = (textEncoder ||= new TextEncoder()).encode(value);\n            bytes.set(bytesToAdd, offset);\n            return offset + bytesToAdd.length;\n        },\n    });\n};\n\n/**\n * Returns a decoder for UTF-8 strings.\n *\n * This decoder deserializes UTF-8 encoded strings from a byte array.\n * It reads all available bytes starting from the given offset.\n *\n * For more details, see {@link getUtf8Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding UTF-8 strings.\n *\n * @example\n * Decoding a UTF-8 string.\n * ```ts\n * const decoder = getUtf8Decoder();\n * const value = decoder.decode(new Uint8Array([0x68, 0x65, 0x6c, 0x6c, 0x6f])); // \"hello\"\n * ```\n *\n * @see {@link getUtf8Codec}\n */\nexport const getUtf8Decoder = (): VariableSizeDecoder<string> => {\n    let textDecoder: TextDecoder;\n    return createDecoder({\n        read(bytes, offset) {\n            const value = (textDecoder ||= new TextDecoder()).decode(bytes.slice(offset));\n            return [removeNullCharacters(value), bytes.length];\n        },\n    });\n};\n\n/**\n * Returns a codec for encoding and decoding UTF-8 strings.\n *\n * This codec serializes strings using UTF-8 encoding.\n * The encoded output contains as many bytes as needed to represent the string.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding UTF-8 strings.\n *\n * @example\n * Encoding and decoding a UTF-8 string.\n * ```ts\n * const codec = getUtf8Codec();\n * const bytes = codec.encode('hello'); // 0x68656c6c6f\n * const value = codec.decode(bytes);   // \"hello\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size UTF-8 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getUtf8Codec(), 5);\n * ```\n *\n * If you need a size-prefixed UTF-8 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getUtf8Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getUtf8Encoder} and {@link getUtf8Decoder} functions are available.\n *\n * ```ts\n * const bytes = getUtf8Encoder().encode('hello');\n * const value = getUtf8Decoder().decode(bytes);\n * ```\n *\n * @see {@link getUtf8Encoder}\n * @see {@link getUtf8Decoder}\n */\nexport const getUtf8Codec = (): VariableSizeCodec<string> => combineCodec(getUtf8Encoder(), getUtf8Decoder());\n"],"names":["alphabet","createEncoder","SolanaError","SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE","createDecoder","combineCodec","TextDecoder","TextEncoder"],"mappings":"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","debugId":null}},
    {"offset": {"line": 2440, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/codecs-strings/dist/index.browser.mjs","sources":["file:///Users/ivaylobakalov/web3/solana/voting-dapp/frontend/node_modules/%40solana/codecs-strings/src/assertions.ts","file:///Users/ivaylobakalov/web3/solana/voting-dapp/frontend/node_modules/%40solana/codecs-strings/src/baseX.ts","file:///Users/ivaylobakalov/web3/solana/voting-dapp/frontend/node_modules/%40solana/codecs-strings/src/base10.ts","file:///Users/ivaylobakalov/web3/solana/voting-dapp/frontend/node_modules/%40solana/codecs-strings/src/base16.ts","file:///Users/ivaylobakalov/web3/solana/voting-dapp/frontend/node_modules/%40solana/codecs-strings/src/base58.ts","file:///Users/ivaylobakalov/web3/solana/voting-dapp/frontend/node_modules/%40solana/codecs-strings/src/baseX-reslice.ts","file:///Users/ivaylobakalov/web3/solana/voting-dapp/frontend/node_modules/%40solana/codecs-strings/src/base64.ts","file:///Users/ivaylobakalov/web3/solana/voting-dapp/frontend/node_modules/%40solana/codecs-strings/src/null-characters.ts","file:///Users/ivaylobakalov/web3/solana/voting-dapp/frontend/node_modules/%40solana/text-encoding-impl/src/index.browser.ts","file:///Users/ivaylobakalov/web3/solana/voting-dapp/frontend/node_modules/%40solana/codecs-strings/src/utf8.ts"],"sourcesContent":["import { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\n/**\n * Asserts that a given string contains only characters from the specified alphabet.\n *\n * This function validates whether a string consists exclusively of characters\n * from the provided `alphabet`. If the validation fails, it throws an error\n * indicating the invalid base string.\n *\n * @param alphabet - The allowed set of characters for the base encoding.\n * @param testValue - The string to validate against the given alphabet.\n * @param givenValue - The original string provided by the user (defaults to `testValue`).\n *\n * @throws {SolanaError} If `testValue` contains characters not present in `alphabet`.\n *\n * @example\n * Validating a base-8 encoded string.\n * ```ts\n * assertValidBaseString('01234567', '123047'); // Passes\n * assertValidBaseString('01234567', '128');    // Throws error\n * ```\n */\nexport function assertValidBaseString(alphabet: string, testValue: string, givenValue = testValue) {\n    if (!testValue.match(new RegExp(`^[${alphabet}]*$`))) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n            alphabet,\n            base: alphabet.length,\n            value: givenValue,\n        });\n    }\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertValidBaseString } from './assertions';\n\n/**\n * Returns an encoder for base-X encoded strings.\n *\n * This encoder serializes strings using a custom alphabet, treating the length of the alphabet as the base.\n * The encoding process involves converting the input string to a numeric value in base-X, then\n * encoding that value into bytes while preserving leading zeroes.\n *\n * For more details, see {@link getBaseXCodec}.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @returns A `VariableSizeEncoder<string>` for encoding base-X strings.\n *\n * @example\n * Encoding a base-X string using a custom alphabet.\n * ```ts\n * const encoder = getBaseXEncoder('0123456789abcdef');\n * const bytes = encoder.encode('deadface'); // 0xdeadface\n * ```\n *\n * @see {@link getBaseXCodec}\n */\nexport const getBaseXEncoder = (alphabet: string): VariableSizeEncoder<string> => {\n    return createEncoder({\n        getSizeFromValue: (value: string): number => {\n            const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet[0]);\n            if (!tailChars) return value.length;\n\n            const base10Number = getBigIntFromBaseX(tailChars, alphabet);\n            return leadingZeroes.length + Math.ceil(base10Number.toString(16).length / 2);\n        },\n        write(value: string, bytes, offset) {\n            // Check if the value is valid.\n            assertValidBaseString(alphabet, value);\n            if (value === '') return offset;\n\n            // Handle leading zeroes.\n            const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet[0]);\n            if (!tailChars) {\n                bytes.set(new Uint8Array(leadingZeroes.length).fill(0), offset);\n                return offset + leadingZeroes.length;\n            }\n\n            // From baseX to base10.\n            let base10Number = getBigIntFromBaseX(tailChars, alphabet);\n\n            // From base10 to bytes.\n            const tailBytes: number[] = [];\n            while (base10Number > 0n) {\n                tailBytes.unshift(Number(base10Number % 256n));\n                base10Number /= 256n;\n            }\n\n            const bytesToAdd = [...Array(leadingZeroes.length).fill(0), ...tailBytes];\n            bytes.set(bytesToAdd, offset);\n            return offset + bytesToAdd.length;\n        },\n    });\n};\n\n/**\n * Returns a decoder for base-X encoded strings.\n *\n * This decoder deserializes base-X encoded strings from a byte array using a custom alphabet.\n * The decoding process converts the byte array into a numeric value in base-10, then\n * maps that value back to characters in the specified base-X alphabet.\n *\n * For more details, see {@link getBaseXCodec}.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @returns A `VariableSizeDecoder<string>` for decoding base-X strings.\n *\n * @example\n * Decoding a base-X string using a custom alphabet.\n * ```ts\n * const decoder = getBaseXDecoder('0123456789abcdef');\n * const value = decoder.decode(new Uint8Array([0xde, 0xad, 0xfa, 0xce])); // \"deadface\"\n * ```\n *\n * @see {@link getBaseXCodec}\n */\nexport const getBaseXDecoder = (alphabet: string): VariableSizeDecoder<string> => {\n    return createDecoder({\n        read(rawBytes, offset): [string, number] {\n            const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);\n            if (bytes.length === 0) return ['', 0];\n\n            // Handle leading zeroes.\n            let trailIndex = bytes.findIndex(n => n !== 0);\n            trailIndex = trailIndex === -1 ? bytes.length : trailIndex;\n            const leadingZeroes = alphabet[0].repeat(trailIndex);\n            if (trailIndex === bytes.length) return [leadingZeroes, rawBytes.length];\n\n            // From bytes to base10.\n            const base10Number = bytes.slice(trailIndex).reduce((sum, byte) => sum * 256n + BigInt(byte), 0n);\n\n            // From base10 to baseX.\n            const tailChars = getBaseXFromBigInt(base10Number, alphabet);\n\n            return [leadingZeroes + tailChars, rawBytes.length];\n        },\n    });\n};\n\n/**\n * Returns a codec for encoding and decoding base-X strings.\n *\n * This codec serializes strings using a custom alphabet, treating the length of the alphabet as the base.\n * The encoding process converts the input string into a numeric value in base-X, which is then encoded as bytes.\n * The decoding process reverses this transformation to reconstruct the original string.\n *\n * This codec supports leading zeroes by treating the first character of the alphabet as the zero character.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-X strings.\n *\n * @example\n * Encoding and decoding a base-X string using a custom alphabet.\n * ```ts\n * const codec = getBaseXCodec('0123456789abcdef');\n * const bytes = codec.encode('deadface'); // 0xdeadface\n * const value = codec.decode(bytes);      // \"deadface\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-X codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBaseXCodec('0123456789abcdef'), 8);\n * ```\n *\n * If you need a size-prefixed base-X codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBaseXCodec('0123456789abcdef'), getU32Codec());\n * ```\n *\n * Separate {@link getBaseXEncoder} and {@link getBaseXDecoder} functions are available.\n *\n * ```ts\n * const bytes = getBaseXEncoder('0123456789abcdef').encode('deadface');\n * const value = getBaseXDecoder('0123456789abcdef').decode(bytes);\n * ```\n *\n * @see {@link getBaseXEncoder}\n * @see {@link getBaseXDecoder}\n */\nexport const getBaseXCodec = (alphabet: string): VariableSizeCodec<string> =>\n    combineCodec(getBaseXEncoder(alphabet), getBaseXDecoder(alphabet));\n\nfunction partitionLeadingZeroes(\n    value: string,\n    zeroCharacter: string,\n): [leadingZeros: string, tailChars: string | undefined] {\n    const [leadingZeros, tailChars] = value.split(new RegExp(`((?!${zeroCharacter}).*)`));\n    return [leadingZeros, tailChars];\n}\n\nfunction getBigIntFromBaseX(value: string, alphabet: string): bigint {\n    const base = BigInt(alphabet.length);\n    let sum = 0n;\n    for (const char of value) {\n        sum *= base;\n        sum += BigInt(alphabet.indexOf(char));\n    }\n    return sum;\n}\n\nfunction getBaseXFromBigInt(value: bigint, alphabet: string): string {\n    const base = BigInt(alphabet.length);\n    const tailChars = [];\n    while (value > 0n) {\n        tailChars.unshift(alphabet[Number(value % base)]);\n        value /= base;\n    }\n    return tailChars.join('');\n}\n","import { getBaseXCodec, getBaseXDecoder, getBaseXEncoder } from './baseX';\n\nconst alphabet = '0123456789';\n\n/**\n * Returns an encoder for base-10 strings.\n *\n * This encoder serializes strings using a base-10 encoding scheme.\n * The output consists of bytes representing the numerical values of the input string.\n *\n * For more details, see {@link getBase10Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding base-10 strings.\n *\n * @example\n * Encoding a base-10 string.\n * ```ts\n * const encoder = getBase10Encoder();\n * const bytes = encoder.encode('1024'); // 0x0400\n * ```\n *\n * @see {@link getBase10Codec}\n */\nexport const getBase10Encoder = () => getBaseXEncoder(alphabet);\n\n/**\n * Returns a decoder for base-10 strings.\n *\n * This decoder deserializes base-10 encoded strings from a byte array.\n *\n * For more details, see {@link getBase10Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding base-10 strings.\n *\n * @example\n * Decoding a base-10 string.\n * ```ts\n * const decoder = getBase10Decoder();\n * const value = decoder.decode(new Uint8Array([0x04, 0x00])); // \"1024\"\n * ```\n *\n * @see {@link getBase10Codec}\n */\nexport const getBase10Decoder = () => getBaseXDecoder(alphabet);\n\n/**\n * Returns a codec for encoding and decoding base-10 strings.\n *\n * This codec serializes strings using a base-10 encoding scheme.\n * The output consists of bytes representing the numerical values of the input string.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-10 strings.\n *\n * @example\n * Encoding and decoding a base-10 string.\n * ```ts\n * const codec = getBase10Codec();\n * const bytes = codec.encode('1024'); // 0x0400\n * const value = codec.decode(bytes);  // \"1024\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-10 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBase10Codec(), 5);\n * ```\n *\n * If you need a size-prefixed base-10 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBase10Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getBase10Encoder} and {@link getBase10Decoder} functions are available.\n *\n * ```ts\n * const bytes = getBase10Encoder().encode('1024');\n * const value = getBase10Decoder().decode(bytes);\n * ```\n *\n * @see {@link getBase10Encoder}\n * @see {@link getBase10Decoder}\n */\nexport const getBase10Codec = () => getBaseXCodec(alphabet);\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\nconst enum HexC {\n    ZERO = 48, // 0\n    NINE = 57, // 9\n    A_UP = 65, // A\n    F_UP = 70, // F\n    A_LO = 97, // a\n    F_LO = 102, // f\n}\n\nconst INVALID_STRING_ERROR_BASE_CONFIG = {\n    alphabet: '0123456789abcdef',\n    base: 16,\n} as const;\n\nfunction charCodeToBase16(char: number) {\n    if (char >= HexC.ZERO && char <= HexC.NINE) return char - HexC.ZERO;\n    if (char >= HexC.A_UP && char <= HexC.F_UP) return char - (HexC.A_UP - 10);\n    if (char >= HexC.A_LO && char <= HexC.F_LO) return char - (HexC.A_LO - 10);\n}\n\n/**\n * Returns an encoder for base-16 (hexadecimal) strings.\n *\n * This encoder serializes strings using a base-16 encoding scheme.\n * The output consists of bytes representing the hexadecimal values of the input string.\n *\n * For more details, see {@link getBase16Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding base-16 strings.\n *\n * @example\n * Encoding a base-16 string.\n * ```ts\n * const encoder = getBase16Encoder();\n * const bytes = encoder.encode('deadface'); // 0xdeadface\n * ```\n *\n * @see {@link getBase16Codec}\n */\nexport const getBase16Encoder = (): VariableSizeEncoder<string> =>\n    createEncoder({\n        getSizeFromValue: (value: string) => Math.ceil(value.length / 2),\n        write(value: string, bytes, offset) {\n            const len = value.length;\n            const al = len / 2;\n            if (len === 1) {\n                const c = value.charCodeAt(0);\n                const n = charCodeToBase16(c);\n                if (n === undefined) {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        ...INVALID_STRING_ERROR_BASE_CONFIG,\n                        value,\n                    });\n                }\n                bytes.set([n], offset);\n                return 1 + offset;\n            }\n            const hexBytes = new Uint8Array(al);\n            for (let i = 0, j = 0; i < al; i++) {\n                const c1 = value.charCodeAt(j++);\n                const c2 = value.charCodeAt(j++);\n\n                const n1 = charCodeToBase16(c1);\n                const n2 = charCodeToBase16(c2);\n                if (n1 === undefined || (n2 === undefined && !Number.isNaN(c2))) {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        ...INVALID_STRING_ERROR_BASE_CONFIG,\n                        value,\n                    });\n                }\n                hexBytes[i] = !Number.isNaN(c2) ? (n1 << 4) | (n2 ?? 0) : n1;\n            }\n\n            bytes.set(hexBytes, offset);\n            return hexBytes.length + offset;\n        },\n    });\n\n/**\n * Returns a decoder for base-16 (hexadecimal) strings.\n *\n * This decoder deserializes base-16 encoded strings from a byte array.\n *\n * For more details, see {@link getBase16Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding base-16 strings.\n *\n * @example\n * Decoding a base-16 string.\n * ```ts\n * const decoder = getBase16Decoder();\n * const value = decoder.decode(new Uint8Array([0xde, 0xad, 0xfa, 0xce])); // \"deadface\"\n * ```\n *\n * @see {@link getBase16Codec}\n */\nexport const getBase16Decoder = (): VariableSizeDecoder<string> =>\n    createDecoder({\n        read(bytes, offset) {\n            const value = bytes.slice(offset).reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n            return [value, bytes.length];\n        },\n    });\n\n/**\n * Returns a codec for encoding and decoding base-16 (hexadecimal) strings.\n *\n * This codec serializes strings using a base-16 encoding scheme.\n * The output consists of bytes representing the hexadecimal values of the input string.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-16 strings.\n *\n * @example\n * Encoding and decoding a base-16 string.\n * ```ts\n * const codec = getBase16Codec();\n * const bytes = codec.encode('deadface'); // 0xdeadface\n * const value = codec.decode(bytes);      // \"deadface\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-16 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBase16Codec(), 8);\n * ```\n *\n * If you need a size-prefixed base-16 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBase16Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getBase16Encoder} and {@link getBase16Decoder} functions are available.\n *\n * ```ts\n * const bytes = getBase16Encoder().encode('deadface');\n * const value = getBase16Decoder().decode(bytes);\n * ```\n *\n * @see {@link getBase16Encoder}\n * @see {@link getBase16Decoder}\n */\nexport const getBase16Codec = (): VariableSizeCodec<string> => combineCodec(getBase16Encoder(), getBase16Decoder());\n","import { getBaseXCodec, getBaseXDecoder, getBaseXEncoder } from './baseX';\n\nconst alphabet = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\n\n/**\n * Returns an encoder for base-58 strings.\n *\n * This encoder serializes strings using a base-58 encoding scheme,\n * commonly used in cryptocurrency addresses and other compact representations.\n *\n * For more details, see {@link getBase58Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding base-58 strings.\n *\n * @example\n * Encoding a base-58 string.\n * ```ts\n * const encoder = getBase58Encoder();\n * const bytes = encoder.encode('heLLo'); // 0x1b6a3070\n * ```\n *\n * @see {@link getBase58Codec}\n */\nexport const getBase58Encoder = () => getBaseXEncoder(alphabet);\n\n/**\n * Returns a decoder for base-58 strings.\n *\n * This decoder deserializes base-58 encoded strings from a byte array.\n *\n * For more details, see {@link getBase58Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding base-58 strings.\n *\n * @example\n * Decoding a base-58 string.\n * ```ts\n * const decoder = getBase58Decoder();\n * const value = decoder.decode(new Uint8Array([0x1b, 0x6a, 0x30, 0x70])); // \"heLLo\"\n * ```\n *\n * @see {@link getBase58Codec}\n */\nexport const getBase58Decoder = () => getBaseXDecoder(alphabet);\n\n/**\n * Returns a codec for encoding and decoding base-58 strings.\n *\n * This codec serializes strings using a base-58 encoding scheme,\n * commonly used in cryptocurrency addresses and other compact representations.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-58 strings.\n *\n * @example\n * Encoding and decoding a base-58 string.\n * ```ts\n * const codec = getBase58Codec();\n * const bytes = codec.encode('heLLo'); // 0x1b6a3070\n * const value = codec.decode(bytes);   // \"heLLo\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-58 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBase58Codec(), 8);\n * ```\n *\n * If you need a size-prefixed base-58 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBase58Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getBase58Encoder} and {@link getBase58Decoder} functions are available.\n *\n * ```ts\n * const bytes = getBase58Encoder().encode('heLLo');\n * const value = getBase58Decoder().decode(bytes);\n * ```\n *\n * @see {@link getBase58Encoder}\n * @see {@link getBase58Decoder}\n */\nexport const getBase58Codec = () => getBaseXCodec(alphabet);\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertValidBaseString } from './assertions';\n\n/**\n * Returns an encoder for base-X encoded strings using bit re-slicing.\n *\n * This encoder serializes strings by dividing the input into custom-sized bit chunks,\n * mapping them to an alphabet, and encoding the result into a byte array.\n * This approach is commonly used for encoding schemes where the alphabet's length is a power of 2,\n * such as base-16 or base-64.\n *\n * For more details, see {@link getBaseXResliceCodec}.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @param bits - The number of bits per encoded chunk, typically `log2(alphabet.length)`.\n * @returns A `VariableSizeEncoder<string>` for encoding base-X strings using bit re-slicing.\n *\n * @example\n * Encoding a base-X string using bit re-slicing.\n * ```ts\n * const encoder = getBaseXResliceEncoder('elho', 2);\n * const bytes = encoder.encode('hellolol'); // 0x4aee\n * ```\n *\n * @see {@link getBaseXResliceCodec}\n */\nexport const getBaseXResliceEncoder = (alphabet: string, bits: number): VariableSizeEncoder<string> =>\n    createEncoder({\n        getSizeFromValue: (value: string) => Math.floor((value.length * bits) / 8),\n        write(value: string, bytes, offset) {\n            assertValidBaseString(alphabet, value);\n            if (value === '') return offset;\n            const charIndices = [...value].map(c => alphabet.indexOf(c));\n            const reslicedBytes = reslice(charIndices, bits, 8, false);\n            bytes.set(reslicedBytes, offset);\n            return reslicedBytes.length + offset;\n        },\n    });\n\n/**\n * Returns a decoder for base-X encoded strings using bit re-slicing.\n *\n * This decoder deserializes base-X encoded strings by re-slicing the bits of a byte array into\n * custom-sized chunks and mapping them to a specified alphabet.\n * This is typically used for encoding schemes where the alphabet's length is a power of 2,\n * such as base-16 or base-64.\n *\n * For more details, see {@link getBaseXResliceCodec}.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @param bits - The number of bits per encoded chunk, typically `log2(alphabet.length)`.\n * @returns A `VariableSizeDecoder<string>` for decoding base-X strings using bit re-slicing.\n *\n * @example\n * Decoding a base-X string using bit re-slicing.\n * ```ts\n * const decoder = getBaseXResliceDecoder('elho', 2);\n * const value = decoder.decode(new Uint8Array([0x4a, 0xee])); // \"hellolol\"\n * ```\n *\n * @see {@link getBaseXResliceCodec}\n */\nexport const getBaseXResliceDecoder = (alphabet: string, bits: number): VariableSizeDecoder<string> =>\n    createDecoder({\n        read(rawBytes, offset = 0): [string, number] {\n            const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);\n            if (bytes.length === 0) return ['', rawBytes.length];\n            const charIndices = reslice([...bytes], 8, bits, true);\n            return [charIndices.map(i => alphabet[i]).join(''), rawBytes.length];\n        },\n    });\n\n/**\n * Returns a codec for encoding and decoding base-X strings using bit re-slicing.\n *\n * This codec serializes strings by dividing the input into custom-sized bit chunks,\n * mapping them to a given alphabet, and encoding the result into bytes.\n * It is particularly suited for encoding schemes where the alphabet's length is a power of 2,\n * such as base-16 or base-64.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @param bits - The number of bits per encoded chunk, typically `log2(alphabet.length)`.\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-X strings using bit re-slicing.\n *\n * @example\n * Encoding and decoding a base-X string using bit re-slicing.\n * ```ts\n * const codec = getBaseXResliceCodec('elho', 2);\n * const bytes = codec.encode('hellolol'); // 0x4aee\n * const value = codec.decode(bytes);      // \"hellolol\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-X codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBaseXResliceCodec('elho', 2), 8);\n * ```\n *\n * If you need a size-prefixed base-X codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBaseXResliceCodec('elho', 2), getU32Codec());\n * ```\n *\n * Separate {@link getBaseXResliceEncoder} and {@link getBaseXResliceDecoder} functions are available.\n *\n * ```ts\n * const bytes = getBaseXResliceEncoder('elho', 2).encode('hellolol');\n * const value = getBaseXResliceDecoder('elho', 2).decode(bytes);\n * ```\n *\n * @see {@link getBaseXResliceEncoder}\n * @see {@link getBaseXResliceDecoder}\n */\nexport const getBaseXResliceCodec = (alphabet: string, bits: number): VariableSizeCodec<string> =>\n    combineCodec(getBaseXResliceEncoder(alphabet, bits), getBaseXResliceDecoder(alphabet, bits));\n\n/** Helper function to reslice the bits inside bytes. */\nfunction reslice(input: number[], inputBits: number, outputBits: number, useRemainder: boolean): number[] {\n    const output = [];\n    let accumulator = 0;\n    let bitsInAccumulator = 0;\n    const mask = (1 << outputBits) - 1;\n    for (const value of input) {\n        accumulator = (accumulator << inputBits) | value;\n        bitsInAccumulator += inputBits;\n        while (bitsInAccumulator >= outputBits) {\n            bitsInAccumulator -= outputBits;\n            output.push((accumulator >> bitsInAccumulator) & mask);\n        }\n    }\n    if (useRemainder && bitsInAccumulator > 0) {\n        output.push((accumulator << (outputBits - bitsInAccumulator)) & mask);\n    }\n    return output;\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\nimport { assertValidBaseString } from './assertions';\nimport { getBaseXResliceDecoder, getBaseXResliceEncoder } from './baseX-reslice';\n\nconst alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n/**\n * Returns an encoder for base-64 strings.\n *\n * This encoder serializes strings using a base-64 encoding scheme,\n * commonly used for data encoding in URLs, cryptographic keys, and binary-to-text encoding.\n *\n * For more details, see {@link getBase64Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding base-64 strings.\n *\n * @example\n * Encoding a base-64 string.\n * ```ts\n * const encoder = getBase64Encoder();\n * const bytes = encoder.encode('hello+world'); // 0x85e965a3ec28ae57\n * ```\n *\n * @see {@link getBase64Codec}\n */\nexport const getBase64Encoder = (): VariableSizeEncoder<string> => {\n    if (__BROWSER__) {\n        return createEncoder({\n            getSizeFromValue: (value: string) => {\n                try {\n                    return (atob as Window['atob'])(value).length;\n                } catch {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        alphabet,\n                        base: 64,\n                        value,\n                    });\n                }\n            },\n            write(value: string, bytes, offset) {\n                try {\n                    const bytesToAdd = (atob as Window['atob'])(value)\n                        .split('')\n                        .map(c => c.charCodeAt(0));\n                    bytes.set(bytesToAdd, offset);\n                    return bytesToAdd.length + offset;\n                } catch {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        alphabet,\n                        base: 64,\n                        value,\n                    });\n                }\n            },\n        });\n    }\n\n    if (__NODEJS__) {\n        return createEncoder({\n            getSizeFromValue: (value: string) => Buffer.from(value, 'base64').length,\n            write(value: string, bytes, offset) {\n                assertValidBaseString(alphabet, value.replace(/=/g, ''));\n                const buffer = Buffer.from(value, 'base64');\n                bytes.set(buffer, offset);\n                return buffer.length + offset;\n            },\n        });\n    }\n\n    return transformEncoder(getBaseXResliceEncoder(alphabet, 6), (value: string): string => value.replace(/=/g, ''));\n};\n\n/**\n * Returns a decoder for base-64 strings.\n *\n * This decoder deserializes base-64 encoded strings from a byte array.\n *\n * For more details, see {@link getBase64Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding base-64 strings.\n *\n * @example\n * Decoding a base-64 string.\n * ```ts\n * const decoder = getBase64Decoder();\n * const value = decoder.decode(new Uint8Array([0x85, 0xe9, 0x65, 0xa3, 0xec, 0x28, 0xae, 0x57])); // \"hello+world\"\n * ```\n *\n * @see {@link getBase64Codec}\n */\nexport const getBase64Decoder = (): VariableSizeDecoder<string> => {\n    if (__BROWSER__) {\n        return createDecoder({\n            read(bytes, offset = 0) {\n                const slice = bytes.slice(offset);\n                const value = (btoa as Window['btoa'])(String.fromCharCode(...slice));\n                return [value, bytes.length];\n            },\n        });\n    }\n\n    if (__NODEJS__) {\n        return createDecoder({\n            read: (bytes, offset = 0) => [Buffer.from(bytes, offset).toString('base64'), bytes.length],\n        });\n    }\n\n    return transformDecoder(getBaseXResliceDecoder(alphabet, 6), (value: string): string =>\n        value.padEnd(Math.ceil(value.length / 4) * 4, '='),\n    );\n};\n\n/**\n * Returns a codec for encoding and decoding base-64 strings.\n *\n * This codec serializes strings using a base-64 encoding scheme,\n * commonly used for data encoding in URLs, cryptographic keys, and binary-to-text encoding.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-64 strings.\n *\n * @example\n * Encoding and decoding a base-64 string.\n * ```ts\n * const codec = getBase64Codec();\n * const bytes = codec.encode('hello+world'); // 0x85e965a3ec28ae57\n * const value = codec.decode(bytes);         // \"hello+world\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-64 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBase64Codec(), 8);\n * ```\n *\n * If you need a size-prefixed base-64 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBase64Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getBase64Encoder} and {@link getBase64Decoder} functions are available.\n *\n * ```ts\n * const bytes = getBase64Encoder().encode('hello+world');\n * const value = getBase64Decoder().decode(bytes);\n * ```\n *\n * @see {@link getBase64Encoder}\n * @see {@link getBase64Decoder}\n */\nexport const getBase64Codec = (): VariableSizeCodec<string> => combineCodec(getBase64Encoder(), getBase64Decoder());\n","/**\n * Removes all null characters (`\\u0000`) from a string.\n *\n * This function cleans a string by stripping out any null characters,\n * which are often used as padding in fixed-size string encodings.\n *\n * @param value - The string to process.\n * @returns The input string with all null characters removed.\n *\n * @example\n * Removing null characters from a string.\n * ```ts\n * removeNullCharacters('hello\\u0000\\u0000'); // \"hello\"\n * ```\n */\nexport const removeNullCharacters = (value: string) =>\n    // eslint-disable-next-line no-control-regex\n    value.replace(/\\u0000/g, '');\n\n/**\n * Pads a string with null characters (`\\u0000`) at the end to reach a fixed length.\n *\n * If the input string is shorter than the specified length, it is padded with null characters\n * until it reaches the desired size. If it is already long enough, it remains unchanged.\n *\n * @param value - The string to pad.\n * @param chars - The total length of the resulting string, including padding.\n * @returns The input string padded with null characters up to the specified length.\n *\n * @example\n * Padding a string with null characters.\n * ```ts\n * padNullCharacters('hello', 8); // \"hello\\u0000\\u0000\\u0000\"\n * ```\n */\nexport const padNullCharacters = (value: string, chars: number) => value.padEnd(chars, '\\u0000');\n","export const TextDecoder = globalThis.TextDecoder;\nexport const TextEncoder = globalThis.TextEncoder;\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { TextDecoder, TextEncoder } from '@solana/text-encoding-impl';\n\nimport { removeNullCharacters } from './null-characters';\n\n/**\n * Returns an encoder for UTF-8 strings.\n *\n * This encoder serializes strings using UTF-8 encoding.\n * The encoded output contains as many bytes as needed to represent the string.\n *\n * For more details, see {@link getUtf8Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding UTF-8 strings.\n *\n * @example\n * Encoding a UTF-8 string.\n * ```ts\n * const encoder = getUtf8Encoder();\n * const bytes = encoder.encode('hello'); // 0x68656c6c6f\n * ```\n *\n * @see {@link getUtf8Codec}\n */\nexport const getUtf8Encoder = (): VariableSizeEncoder<string> => {\n    let textEncoder: TextEncoder;\n    return createEncoder({\n        getSizeFromValue: value => (textEncoder ||= new TextEncoder()).encode(value).length,\n        write: (value: string, bytes, offset) => {\n            const bytesToAdd = (textEncoder ||= new TextEncoder()).encode(value);\n            bytes.set(bytesToAdd, offset);\n            return offset + bytesToAdd.length;\n        },\n    });\n};\n\n/**\n * Returns a decoder for UTF-8 strings.\n *\n * This decoder deserializes UTF-8 encoded strings from a byte array.\n * It reads all available bytes starting from the given offset.\n *\n * For more details, see {@link getUtf8Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding UTF-8 strings.\n *\n * @example\n * Decoding a UTF-8 string.\n * ```ts\n * const decoder = getUtf8Decoder();\n * const value = decoder.decode(new Uint8Array([0x68, 0x65, 0x6c, 0x6c, 0x6f])); // \"hello\"\n * ```\n *\n * @see {@link getUtf8Codec}\n */\nexport const getUtf8Decoder = (): VariableSizeDecoder<string> => {\n    let textDecoder: TextDecoder;\n    return createDecoder({\n        read(bytes, offset) {\n            const value = (textDecoder ||= new TextDecoder()).decode(bytes.slice(offset));\n            return [removeNullCharacters(value), bytes.length];\n        },\n    });\n};\n\n/**\n * Returns a codec for encoding and decoding UTF-8 strings.\n *\n * This codec serializes strings using UTF-8 encoding.\n * The encoded output contains as many bytes as needed to represent the string.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding UTF-8 strings.\n *\n * @example\n * Encoding and decoding a UTF-8 string.\n * ```ts\n * const codec = getUtf8Codec();\n * const bytes = codec.encode('hello'); // 0x68656c6c6f\n * const value = codec.decode(bytes);   // \"hello\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size UTF-8 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getUtf8Codec(), 5);\n * ```\n *\n * If you need a size-prefixed UTF-8 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getUtf8Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getUtf8Encoder} and {@link getUtf8Decoder} functions are available.\n *\n * ```ts\n * const bytes = getUtf8Encoder().encode('hello');\n * const value = getUtf8Decoder().decode(bytes);\n * ```\n *\n * @see {@link getUtf8Encoder}\n * @see {@link getUtf8Decoder}\n */\nexport const getUtf8Codec = (): VariableSizeCodec<string> => combineCodec(getUtf8Encoder(), getUtf8Decoder());\n"],"names":["alphabet","createEncoder","SolanaError","SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE","createDecoder","combineCodec","TextDecoder","TextEncoder"],"mappings":"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","debugId":null}}]
}